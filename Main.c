#pragma config(Sensor, in1,    secondaryBattery, sensorAnalog)
#pragma config(Sensor, in2,    gyro1,          sensorGyro)
#pragma config(Sensor, in3,    gyro2,          sensorGyro)
#pragma config(Sensor, in6,    potentiometerMoGoLift, sensorPotentiometer)
#pragma config(Sensor, in4,    potentiometerMini4Bar, sensorPotentiometer)
#pragma config(Sensor, in8,    potentiometerArm, sensorPotentiometer)
#pragma config(Sensor, dgtl2,  limitSwitchArm2, sensorTouch)
#pragma config(Sensor, dgtl4,  LED,            sensorLEDtoVCC)
#pragma config(Sensor, dgtl8,  limitSwitchArm1, sensorTouch)
#pragma config(Sensor, dgtl9,  encoderDriveLeft, sensorQuadEncoder)
#pragma config(Sensor, dgtl11, encoderDriveRight, sensorQuadEncoder)
#pragma config(Motor,  port1,           motorMini4Bar, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port2,           motorDriveLeftFront, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           motorDriveLeftBack, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           motorMoGoLiftRight, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           motorMoGoLiftLeft, tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port6,           motorArmLeftBottom, tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port7,           motorArmRightBottomAndLeftTop,  tmotorServoContinuousRotation, openLoop) // Expander A and B
#pragma config(Motor,  port8,           motorDriveRightFrontBack, tmotorServoContinuousRotation, openLoop, reversed) //Expander D is Back and C is Front
#pragma config(Motor,  port9,           motorArmRightTop, tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port10,          motorGoliath, tmotorServoContinuousRotation, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//!IMPORTANT -> Comment out this line to disable competition mode
//#define competitionEnabled


/* Some constant definitions used in the code */

/* These definitions put a name behind the IDs that each LCD button represents */
#define isLCDEnabled					true
#define LCDLeftButton					1
#define LCDCenterButton					2
#define LCDRightButton					4

//#define ENCODER_SCROLL_WHEEL_THRESHOLD	50
//#define ENCODER_SCROLL_WHEEL_MULTIPLIER	1

#define COLOR_BLUE	false
#define COLOR_RED	true
#define SIDE_LEFT	false
#define SIDE_RIGHT	true

#define IS_PID_ENABLED				false
#define IS_CONTROL_LOCK_ENABLED		false

#define BTN_JOY_LCD_SELECT				Btn6U
#define BTN_JOY_LCD_PREVIOUS			Btn8L
#define BTN_JOY_LCD_NEXT				Btn8R

#define BTN_CONTROL_LOCK_1				Btn8U
#define BTN_CONTROL_LOCK_2				Btn7U
#define BTN_SENSOR_OVERRIDE				Btn7U
#define BTN_STOP_AUTON_RECORDER			Btn7L

#define BTN_GOLIATH_REVERSE				Btn6U

#define BTN_ARM_HIGH_GOAL_PID     		Btn7D

#define BTN_MOGO_LIFT_TOGGLE_AUTO		Btn5U
#define BTN_MOGO_LIFT_EXTEND_MANUAL		Btn5U
#define BTN_MOGO_LIFT_RETRACT_MANUAL	Btn5D
#define BTN_MOGO_LIFT_HALFWAY_AUTO		Btn7L

#define BTN_MINI_4_BAR_HOLD_AUTO		Btn6D
#define BTN_MINI_4_BAR_EXTEND_MANUAL	Btn8D
#define BTN_MINI_4_BAR_RETRACT_MANUAL	Btn8R
#define BTN_MINI_4_BAR_TOGGLE_ENABLE	Btn8D
#define BTN_MINI_4_BAR_TOGGLE_AUTO		Btn6D

#define BTN_READY_ARM_MACRO				Btn8U
#define BTN_MOGO_STACK_MACRO			Btn8L


/* For Motor checker */
#define BTN_NEXT_MOTOR			Btn8R
#define BTN_PREVIOUS_MOTOR		Btn8L
#define BTN_POSITIVE_POWER		Btn6U
#define BTN_NEGATIVE_POWER		Btn5U
#define BTN_STOP_MOTOR			Btn7D
#define BTN_STOP_ALL_MOTORS		Btn7U



#define JOY_DRIVE_X		Ch1
#define JOY_DRIVE_Y		Ch2
#define JOY_ARM			Ch3
#define JOY_CLAW		Ch4
#define JOY_LCD_X		Ch1
#define JOY_LCD_Y		Ch2


#define	LCD_JOYSTICK_DEADZONE	20
#define DRIVE_JOYSTICK_DEADZONE	20
#define ARM_JOYSTICK_DEADZONE	20
#define CLAW_JOYSTICK_DEADZONE	20

#define IS_DRIVE_ENABLED				true
#define DRIVE_ENCODER_LEFT_MULTIPLIER	1
#define DRIVE_ENCODER_RIGHT_MULTIPLIER	1

#define IS_ARM_ENABLED								true
#define ARM_POTENTIOMETER_MIN_VALUE					1080
#define ARM_POTENTIOMETER_MAX_VALUE					2870
#define ARM_POTENTIOMETER_HIGH_GOAL_VALUE			1850
#define ARM_POTENTIOMETER_CONE_HEIGHT_VALUE  		1030
#define ARM_POTENTIOMETER_CONE_STACK_INITIAL_VALUE	1080
#define ARM_POTENTIOMETER_CONE_MULTIPLIER			60
#define ARM_POTENTIOMETER_OFFSET					-100
#define ARM_POTENTIOMETER_MULTIPLIER 				1

#define IS_MOGO_LIFT_ENABLED					true
#define MOGO_LIFT_POTENTIOMETER_EXTENDED_VALUE	3380
#define MOGO_LIFT_POTENTIOMETER_RETRACTED_VALUE	1420
#define MOGO_LIFT_POTENTIOMETER_HALFWAY_VALUE	2020
#define	MOGO_LIFT_POTENTIOMETER_OFFSET 			-30
#define MOGO_LIFT_POTENTIOMETER_MULTIPLIER		1


#define IS_MINI_4_BAR_ENABLED						true
#define MINI_4_BAR_POTENTIOMETER_EXTENDED_VALUE 	2000
#define MINI_4_BAR_POTENTIOMETER_RETRACTED_VALUE 	530
#define MINI_4_BAR_POTENTIOMETER_PARALLEL_VALUE		1980
#define MINI_4_BAR_POTENTIOMETER_OFFSET				0
#define MINI_4_BAR_POTENTIOMETER_MULTIPLIER 		1

#define IS_GOLIATH_ENABLED		true
#define GOLIATH_INTAKE_POWER	50
#define GOLIATH_REST_POWER		45
#define GOLIATH_OUTTAKE_POWER	-50


#define IS_SLEW_RATE_ENABLED	true

#define GYRO_MULTIPLIER	1

#define PASSWORD_ENABLED 	false


/* For motor checker */
#define MOTOR_TEST_DURATION			2000	// Amount of time to power motors during autocheck
#define MOTOR_TEST_POWER			-127	// Amount of power to give motors during autocheck
#define ERROR_BOUNDS_ENCODER		0		// Amount encoder should change to indicate a working motor
#define ERROR_BOUNDS_POTENTIOMETER	7		// Amount a potentiometer should change to indicate a working motor

/* Number of items in each menu list */
#define MENU_LIST_MAIN_LENGTH			9
#define MENU_LIST_AUTON_LENGTH 			10
#define MENU_LIST_SIDES_LENGTH 			3
#define MENU_LIST_COLORS_LENGTH			3
#define MENU_LIST_PID_LENGTH			7
#define MENU_LIST_MOTOR_CHECK_LENGTH 	3


enum Action { A_DRIVE, A_ARM, A_GOLIATH, A_MINI_4_BAR, A_MOGO_LIFT, A_GYRO, A_ARM_READY_MACRO, A_MOGO_CARRY_CONE_MACRO, A_NONE,
	A_DRIVE_WAIT, A_ARM_WAIT, A_GOLIATH_WAIT, A_MINI_4_BAR_WAIT, A_MOGO_LIFT_WAIT, A_GYRO_WAIT, A_ARM_READY_MACRO_WAIT, A_MOGO_CARRY_CONE_MACRO_WAIT };
enum StateExtension { STATE_EXTENSION_EXTENDED, STATE_EXTENSION_RETRACTED, STATE_EXTENSION_HALFWAY };
enum StateGoliath { STATE_GOLIATH_INTAKE, STATE_GOLIATH_OUTTAKE, STATE_OFF };
enum WaitForAction { WAIT, WAIT_NONE };
enum Macro { MACRO_ARM_READY, MACRO_MOGO_STACK_CONE };
enum Mode { MODE_ACCURATE, MODE_FAST, MODE_MOGO };
enum OnStall { ON_STALL_EXIT, ON_STALL_NOTHING };

struct MenuItem {
	short id;
	short idx;
	string name;
	string LCDAction;
	bool isDirectional;
};


//main screen menu items
MenuItem menuItemUserControl, menuItemPIDMode, menuItemMotorCheck, menuItemAutonRecorder, menuItemSwitchCompetitionMode, menuItemGoToAuton, menuItemResetGyro, menuItemBatteryLevel, menuItemCurrentProgram;
//autonomous menu items
MenuItem menuItemAutonGoBack, menuItemAuton22P, menuItemAuton24P, menuItemAuton12P, menuItemAuton14P, menuItemAuton7P, menuItemAuton9P, menuItemAutonR10P, menuItemAutonNone, menuItemProgSkills1;
//side menu items
MenuItem menuItemSideGoBack, menuItemSideLeft, menuItemSideRight;
//color menu items
MenuItem menuItemColorGoBack, menuItemColorBlue, menuItemColorRed;
//pid menu items
MenuItem menuItemPIDGoBack, menuItemPIDDrive, menuItemPIDGyro, menuItemPIDArm, menuItemPIDMini4Bar, menuItemPIDMoGoLift, menuItemPIDCustom;
//Motor Check Menu Items
MenuItem menuItemMotorCheckGoBack, menuItemMotorCheckAuto, menuItemMotorCheckManual;

//screen lists for LCD
MenuItem* menuListMain[MENU_LIST_MAIN_LENGTH];
MenuItem* menuListAuton[MENU_LIST_AUTON_LENGTH];
MenuItem* menuListSides[MENU_LIST_SIDES_LENGTH];
MenuItem* menuListColors[MENU_LIST_COLORS_LENGTH];
MenuItem* menuListPID[MENU_LIST_PID_LENGTH];
MenuItem* menuListMotorCheck[MENU_LIST_MOTOR_CHECK_LENGTH];

MenuItem* currentMenu;

MenuItem *startupLCDProgram = &menuItemUserControl;

/* add all the menuItems to their respective lists by reference
and assign ids and indices to each item */
void populateMenuItems() {
	ubyte i = 0;
	ubyte id = 0;

	menuItemUserControl.name = "User Control";
	menuItemUserControl.LCDAction = "Start";
	menuItemUserControl.idx = i;
	menuItemUserControl.id = id;
	menuListMain[i] = &menuItemUserControl;

	menuItemPIDMode.name = "PID Mode";
	menuItemPIDMode.id = ++id;
	menuItemPIDMode.idx = ++i;
	menuItemPIDMode.LCDAction = "Select";
	menuListMain[i] = &menuItemPIDMode;

	menuItemMotorCheck.name = "Motor Check";
	menuItemMotorCheck.id = ++id;
	menuItemMotorCheck.idx = ++i;
	menuItemMotorCheck.LCDAction = "Select";
	menuListMain[i] = &menuItemMotorCheck;

	menuItemAutonRecorder.name = "Auton Recorder";
	menuItemAutonRecorder.id = ++id;
	menuItemAutonRecorder.idx = ++i;
	menuItemAutonRecorder.LCDAction = "Select";
	menuListMain[i] = &menuItemAutonRecorder;

	menuItemSwitchCompetitionMode.name = "Switch Comp. Mode";
	menuItemSwitchCompetitionMode.id = ++id;
	menuItemSwitchCompetitionMode.idx = ++i;
	menuItemSwitchCompetitionMode.LCDAction = "Select";
	menuListMain[i] = &menuItemSwitchCompetitionMode;

	menuItemGoToAuton.name = "Go To Autonomous";
	menuItemGoToAuton.id = ++id;
	menuItemGoToAuton.idx = ++i;
	menuItemGoToAuton.LCDAction = "Select";
	menuListMain[i] = &menuItemGoToAuton;

	menuItemResetGyro.name = "Reset Gyro";
	menuItemResetGyro.id = ++id;
	menuItemResetGyro.idx = ++i;
	menuItemResetGyro.LCDAction = "Reset";
	menuListMain[i] = &menuItemResetGyro;

	menuItemBatteryLevel.name = "Battery Level";
	menuItemBatteryLevel.id = ++id;
	menuItemBatteryLevel.idx = ++i;
	menuItemBatteryLevel.LCDAction = "Select";
	menuListMain[i] = &menuItemBatteryLevel;

	menuItemCurrentProgram.name = "Current Program";
	menuItemCurrentProgram.id = ++id;
	menuItemCurrentProgram.idx = ++i;
	menuListMain[i] = &menuItemCurrentProgram;

	i = 0;

	menuItemAutonGoBack.name = "Go Back";
	menuItemAutonGoBack.id = ++id;
	menuItemAutonGoBack.idx = i;
	menuItemAutonGoBack.LCDAction = "Select";
	menuListAuton[i] = &menuItemAutonGoBack;

	menuItemAuton22P.name = "Auton22P";
	menuItemAuton22P.id = ++id;
	menuItemAuton22P.idx = ++i;
	menuItemAuton22P.isDirectional = true;
	menuListAuton[i] = &menuItemAuton22P;

	menuItemAuton24P.name = "Auton24P";
	menuItemAuton24P.id = ++id;
	menuItemAuton24P.idx = ++i;
	menuItemAuton24P.isDirectional = true;
	menuListAuton[i] = &menuItemAuton24P;

	menuItemAuton7P.name = "Auton7P";
	menuItemAuton7P.id = ++id;
	menuItemAuton7P.idx = ++i;
	menuItemAuton7P.isDirectional = true;
	menuListAuton[i] = &menuItemAuton7P;

	menuItemAuton9P.name = "Auton9P";
	menuItemAuton9P.id = ++id;
	menuItemAuton9P.idx = ++i;
	menuItemAuton9P.isDirectional = true;
	menuListAuton[i] = &menuItemAuton9P;

	menuItemAuton12P.name = "Auton12P";
	menuItemAuton12P.id = ++id;
	menuItemAuton12P.idx = ++i;
	menuItemAuton12P.isDirectional = true;
	menuListAuton[i] = &menuItemAuton12P;

	menuItemAuton14P.name = "Auton14P";
	menuItemAuton14P.id = ++id;
	menuItemAuton14P.idx = ++i;
	menuItemAuton14P.isDirectional = true;
	menuListAuton[i] = &menuItemAuton14P;

	menuItemAutonR10P.name = "AutonR10P";
	menuItemAutonR10P.id = ++id;
	menuItemAutonR10P.idx = ++i;
	menuItemAutonR10P.isDirectional = true;
	menuListAuton[i] = &menuItemAutonR10P;

	menuItemAutonNone.name = "AutonNone";
	menuItemAutonNone.id = ++id;
	menuItemAutonNone.idx = ++i;
	menuItemAutonNone.isDirectional = true;
	menuListAuton[i] = &menuItemAutonNone;

	menuItemProgSkills1.name = "Prog. Skills 1";
	menuItemProgSkills1.id = ++id;
	menuItemProgSkills1.idx = ++i;
	menuItemProgSkills1.isDirectional = true;
	menuListAuton[i] = &menuItemProgSkills1;

	i = 0;

	menuItemSideGoBack.name = "Go Back";
	menuItemSideGoBack.id = ++id;
	menuItemSideGoBack.idx = i;
	menuItemSideGoBack.LCDAction = "Select";
	menuListSides[i] = &menuItemSideGoBack;

	menuItemSideLeft.name = "L";
	menuItemSideLeft.id = ++id;
	menuItemSideLeft.idx = ++i;
	menuItemSideLeft.LCDAction = "Select";
	menuListSides[i] = &menuItemSideLeft;

	menuItemSideRight.name = "R";
	menuItemSideRight.id = ++id;
	menuItemSideRight.idx = ++i;
	menuItemSideRight.LCDAction = "Select";
	menuListSides[i] = &menuItemSideRight;

	i = 0;

	menuItemColorGoBack.name = "Go Back";
	menuItemColorGoBack.id = ++id;
	menuItemColorGoBack.idx = i;
	menuItemColorGoBack.LCDAction = "Select";
	menuListColors[i] = &menuItemColorGoBack;

	menuItemColorBlue.name = "B";
	menuItemColorBlue.id = ++id;
	menuItemColorBlue.idx = ++i;
	menuItemColorBlue.LCDAction = "Select";
	menuListColors[i] = &menuItemColorBlue;

	menuItemColorRed.name = "R";
	menuItemColorRed.id = ++id;
	menuItemColorRed.idx = ++i;
	menuItemColorRed.LCDAction = "Select";
	menuListColors[i] = &menuItemColorRed;

	i = 0;

	menuItemPIDGoBack.name = "Go Back";
	menuItemPIDGoBack.id = ++id;
	menuItemPIDGoBack.idx = i;
	menuItemPIDGoBack.LCDAction = "Select";
	menuItemPIDGoBack.isDirectional = false;
	menuListPID[i] = &menuItemPIDGoBack;

	menuItemPIDDrive.name = "Drive";
	menuItemPIDDrive.id = ++id;
	menuItemPIDDrive.idx = ++i;
	menuItemPIDDrive.LCDAction = "Start";
	menuItemPIDDrive.isDirectional = false;
	menuListPID[i] = &menuItemPIDDrive;

	menuItemPIDGyro.name = "Gyro";
	menuItemPIDGyro.id = ++id;
	menuItemPIDGyro.idx = ++i;
	menuItemPIDGyro.LCDAction = "Start";
	menuItemPIDGyro.isDirectional = false;
	menuListPID[i] = &menuItemPIDGyro;

	menuItemPIDArm.name = "Arm";
	menuItemPIDArm.id = ++id;
	menuItemPIDArm.idx = ++i;
	menuItemPIDArm.LCDAction = "Start";
	menuItemPIDArm.isDirectional = false;
	menuListPID[i] = &menuItemPIDArm;

	menuItemPIDMini4Bar.name = "Mini 4-Bar";
	menuItemPIDMini4Bar.id = ++id;
	menuItemPIDMini4Bar.idx = ++i;
	menuItemPIDMini4Bar.LCDAction = "Start";
	menuItemPIDMini4Bar.isDirectional = false;
	menuListPID[i] = &menuItemPIDMini4Bar;

	menuItemPIDMoGoLift.name = "MoGo Lift";
	menuItemPIDMoGoLift.id = ++id;
	menuItemPIDMoGoLift.idx = ++i;
	menuItemPIDMoGoLift.LCDAction = "Start";
	menuItemPIDMoGoLift.isDirectional = false;
	menuListPID[i] = &menuItemPIDMoGoLift;

	menuItemPIDCustom.name = "Custom";
	menuItemPIDCustom.id = ++id;
	menuItemPIDCustom.idx = ++i;
	menuItemPIDCustom.LCDAction = "Start";
	menuItemPIDCustom.isDirectional = false;
	menuListPID[i] = &menuItemPIDCustom;

	i = 0;

	menuItemMotorCheckGoBack.name = "Go Back";
	menuItemMotorCheckGoBack.id = ++id;
	menuItemMotorCheckGoBack.idx = i;
	menuItemMotorCheckGoBack.LCDAction = "Select";
	menuItemMotorCheckGoBack.isDirectional = false;
	menuListMotorCheck[i] = &menuItemMotorCheckGoBack;

	menuItemMotorCheckAuto.name = "Auto-Check";
	menuItemMotorCheckAuto.id = ++id;
	menuItemMotorCheckAuto.idx = ++i;
	menuItemMotorCheckAuto.LCDAction = "Start";
	menuItemMotorCheckAuto.isDirectional = false;
	menuListMotorCheck[i] = &menuItemMotorCheckAuto;

	menuItemMotorCheckManual.name = "Manual-Check";
	menuItemMotorCheckManual.id = ++id;
	menuItemMotorCheckManual.idx = ++i;
	menuItemMotorCheckManual.LCDAction = "Start";
	menuItemMotorCheckManual.isDirectional = false;
	menuListMotorCheck[i] = &menuItemMotorCheckManual;

	currentMenu = menuListMain;
}













/* competition code from VEX */
#pragma platform(VEX2)
#pragma competitionControl(Competition)

void pre_auton();
task autonomous();
task usercontrol();

bool bStopTasksBetweenModes = true;
#if !defined(VEX2) && !defined(VEX)
#error "Switch to the VEX cortex platform"
#endif

void allMotorsOff();
void stopTasks();
bool isCompetitionMode = false;

task main()
{
	clearLCDLine(0);
	clearLCDLine(1);
	displayLCDPos(0, 0);
	displayNextLCDString("Startup");
	wait1Msec(2000);
	clearLCDLine(0);

	pre_auton();

	while (true)
	{
		if (isCompetitionMode)
		{
			// remain in this loop while the robot is disabled
			while (bIfiRobotDisabled)
			{
				while (true)
				{
					if (!bIfiRobotDisabled)
						break;
					wait1Msec(25);
				}
			}

			if (bIfiAutonomousMode)
			{
				startTask(autonomous);

				// Waiting for autonomous phase to end
				while (bIfiAutonomousMode && !bIfiRobotDisabled)
				{
					if (!bVEXNETActive)
					{
						if (nVexRCReceiveState == vrNoXmiters) // the transmitters are powered off!!
							allMotorsOff();
					}
					wait1Msec(25);               // Waiting for autonomous phase to end
				}
				allMotorsOff();
				if(bStopTasksBetweenModes)
				{
					stopTasks();
				}
			}

			else
			{
				startTask(usercontrol);

				// Here we repeat loop waiting for user control to end and (optionally) start
				// of a new competition run
				while (!bIfiAutonomousMode && !bIfiRobotDisabled)
				{
					if (nVexRCReceiveState == vrNoXmiters) // the transmitters are powered off!!
						allMotorsOff();
					wait1Msec(25);
				}
				allMotorsOff();
				if(bStopTasksBetweenModes)
				{
					stopTasks();
				}
			}
		}
	}
}

void allMotorsOff()
{
	motor[port1] = 0;
	motor[port2] = 0;
	motor[port3] = 0;
	motor[port4] = 0;
	motor[port5] = 0;
	motor[port6] = 0;
	motor[port7] = 0;
	motor[port8] = 0;
#if defined(VEX2)
	motor[port9] = 0;
	motor[port10] = 0;
#endif
}


























/*---------------------------------------------------------------------------*/
/*																			 */
/*							Pre-Autonomous Functions						 */
/*																			 */
/*---------------------------------------------------------------------------*/

/* references to procedures and tasks */
void startUp();
task loadLCDScreen();
task usercontrol();
task MiscellaneousTask();

MenuItem *selectedProgram;
ubyte LCDScreenMin = menuItemGoToAuton.idx; //minimum index for Screen List
ubyte LCDScreenMax = menuItemBatteryLevel.idx; //maximum index for Screen List
ubyte LCDScreen = 0; //current index of menuItem
bool autonomousSide = SIDE_LEFT; //side selected for autonomous
bool autonomousColor = COLOR_BLUE;
int LCDActiveTime = 0; //amount of time LCD has been inactive

/* What the second line of the LCD should display on a menuItem */
string LCDAction = "<     Start    >";

/* if  this button is pressed the LCD will be controllable from the joystick */
bool isJoystickLCDMode() {
	return (vexRT[Btn7R] == 1);
}


void waitForLCDButtonRelease()
{
	//while these buttons are being pressed, keep waiting
	while (!(nLCDButtons == 0 && vexRT[BTN_JOY_LCD_PREVIOUS] == 0 && vexRT[BTN_JOY_LCD_SELECT] == 0 && vexRT[BTN_JOY_LCD_NEXT] == 0) )
	{
		wait1Msec(10);
	}
}

bool isTaskActive()
{
	//check if the main tasks are active
	if (getTaskState(usercontrol) != taskStateStopped || getTaskState(autonomous) != taskStateStopped || getTaskState(MiscellaneousTask) != taskStateStopped)
		return true;

	return false;
}

float getRadAngleFromTanRatio(float y, float x)
{
	if (x == 0) x = 0.001;
	float angle = atan( abs(y) / abs(x));

	if (x > 0 && y > 0) return angle;
	else if (x < 0 && y > 0) return PI - angle;
	else if (x < 0 && y < 0) return PI + angle;
	else if (x > 0 && y < 0) return 2.0*PI - angle;

	return angle;
}


void waitForLCDButtonPress()
{
	while (nLCDButtons == 0 && ( !isJoystickLCDMode() || (vexRT[BTN_JOY_LCD_PREVIOUS] == 0 && vexRT[BTN_JOY_LCD_SELECT] == 0 && vexRT[BTN_JOY_LCD_NEXT] == 0  && abs(vexRT[JOY_LCD_X]) < LCD_JOYSTICK_DEADZONE && abs(vexRT[JOY_LCD_Y]) < LCD_JOYSTICK_DEADZONE) ))
	{
		wait1Msec(10);
	}

	if (abs(vexRT[JOY_LCD_X]) > LCD_JOYSTICK_DEADZONE || abs(vexRT[JOY_LCD_Y]) > LCD_JOYSTICK_DEADZONE)
	{
		LCDScreen = floor( getRadAngleFromTanRatio(vexRT[JOY_LCD_Y], vexRT[JOY_LCD_X]) / (2.0*PI / (float)(LCDScreenMax - LCDScreenMin + 1) ) );
	}
}


/* Increment the index or jump to start of list */
void LCDNextScreen()
{
	if (LCDScreen < LCDScreenMax) LCDScreen++;
	else LCDScreen = LCDScreenMin;
}

/* Decrement the index or jump to end of list */
void LCDPreviousScreen()
{
	if (LCDScreen > LCDScreenMin) LCDScreen--;
	else LCDScreen = LCDScreenMax;
}


void displayBatteryLevelOnLCD()
{
	clearLCDLine(0);
	clearLCDLine(1);
	string mainBattery, backupBattery;

	sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel / 1000.0, 'V');
	sprintf(backupBattery, "%1.2f%c", SensorValue[secondaryBattery] / 280.0, 'V');

	displayLCDString(0, 0, "Primary: ");
	displayNextLCDString(mainBattery);
	displayLCDString(1, 0, "Secondary: ");
	displayNextLCDString(backupBattery);
}

short getGyroSensorValue();

void reconfigureMenu(void* menuList, ubyte newLCDScreen, ubyte newLCDScreenMin, ubyte newLCDScreenMax)
{
	currentMenu = menuList;
	LCDScreen = newLCDScreen;
	LCDScreenMin = newLCDScreenMin;
	LCDScreenMax = newLCDScreenMax;
}

void displayProgram()
{
	string programName = (currentMenu[LCDScreen]).name; //name of displayed menuItem

	/* if current menu screen is the battery level screen, display battery level */
	if (currentMenu[LCDScreen].id == menuItemBatteryLevel.id)
	{
		displayBatteryLevelOnLCD();
	}
	/* if current menu screen is on the current program screen, display its name */
	else if (currentMenu[LCDScreen].id == menuItemCurrentProgram.id)
	{
		displayLCDCenteredString(0, "Daud-_-Jaan");
		displayLCDCenteredString(1, (*selectedProgram).name);
	}
	/* If the current menu is the directions menu add an L or an R to the end of the auton program name to indicate direction */
	else if (currentMenu == menuListSides && ( currentMenu[LCDScreen].id == menuItemSideLeft.id || currentMenu[LCDScreen].id == menuItemSideRight.id) )
	{
		programName = (*selectedProgram).name;
		if (currentMenu[LCDScreen].id == menuItemSideLeft.id) programName += "L";
		else programName += "R";
		displayLCDCenteredString(0, programName);
	}
	else if (currentMenu == menuListColors && ( currentMenu[LCDScreen].id == menuItemColorBlue.id || currentMenu[LCDScreen].id == menuItemColorRed.id) )
	{
		programName = (*selectedProgram).name;
		if (currentMenu[LCDScreen].id == menuItemColorBlue.id) programName += "B";
		else programName += "R";
		displayLCDCenteredString(0, programName);
	}
	/* If the current menu item is strictly a navigation item, change the second line to read "Select" */
	else if (currentMenu[LCDScreen].isDirectional)
	{
		displayLCDCenteredString(0, currentMenu[LCDScreen].name); //display menuItem name
		displayLCDCenteredString(1, "<    Select    >");
	}
	else if (currentMenu[LCDScreen].id == menuItemResetGyro.id)
	{
		displayLCDCenteredString(0, currentMenu[LCDScreen].name); //display menuItem name
		waitForLCDButtonRelease();
		string gyroValue;
		displayLCDString(1, 0, "< Reset (");
		/* Get value of gyro sensor and print it to the LCD Screen */
		while (nLCDButtons == 0 && vexRT[BTN_JOY_LCD_NEXT] == 0 && vexRT[BTN_JOY_LCD_PREVIOUS] == 0 && vexRT[BTN_JOY_LCD_SELECT] == 0)
		{
			sprintf(gyroValue, "%4.0f%c", getGyroSensorValue()); //convert to string format to 4 digits
			gyroValue += ")";
			displayLCDString(1, 9, gyroValue);
			displayLCDString(1, 15, ">");

			if (abs(vexRT[JOY_LCD_X]) > LCD_JOYSTICK_DEADZONE && abs(vexRT[JOY_LCD_Y]) > LCD_JOYSTICK_DEADZONE) break;
		}
	}
	/* Display the current mode of the Robot when on this menu screen. */
	else if (currentMenu[LCDScreen].id == menuItemSwitchCompetitionMode.id)
	{
		if (isCompetitionMode) displayLCDCenteredString(0, "Comp Mode Active");
		else displayLCDCenteredString(0, "Test Mode Active");
		displayLCDCenteredString(1, "Switch  Mode");
	}
	else
	{
		displayLCDCenteredString(0, currentMenu[LCDScreen].name); //display menuItem name
		displayLCDCenteredString(1, LCDAction); //display possible action
	}

	if (currentMenu[LCDScreen].id != menuItemResetGyro.id && currentMenu[LCDScreen].id != menuItemCurrentProgram.id && currentMenu[LCDScreen].id != menuItemBatteryLevel.id)
	{
		displayLCDString(1, 0, "<");
		displayLCDString(1, 15, ">");
	}

	waitForLCDButtonPress();

	/* If the Left and Right LCD Buttons are pressed, display the battery level. */
	if (nLCDButtons == LCDLeftButton + LCDRightButton || (vexRT[BTN_JOY_LCD_NEXT] == 1 && vexRT[BTN_JOY_LCD_PREVIOUS] == 1))
	{
		while (nLCDButtons == LCDLeftButton + LCDRightButton || (vexRT[BTN_JOY_LCD_NEXT] == 1 && vexRT[BTN_JOY_LCD_PREVIOUS] == 1))
		{
			displayBatteryLevelOnLCD();
		}
	}
	/* If the left LCD Button is pressed (or joystick equivelent), go to the previous menuItem in list (Previous Screen) */
	else if (nLCDButtons == LCDLeftButton || vexRT[BTN_JOY_LCD_PREVIOUS] == 1)
	{
		waitForLCDButtonRelease();
		LCDPreviousScreen();
	}
	/* If the right LCD Button is pressed (or joystick equivelent), go to the next menuItem in the list (Next screen) */
	else if (nLCDButtons == LCDRightButton || vexRT[BTN_JOY_LCD_NEXT] == 1)
	{
		waitForLCDButtonRelease();
		LCDNextScreen();
	}
	/* If the center LCD Button is pressed (or joystick equivelent)... */
	else if ( (nLCDButtons == LCDCenterButton || vexRT[BTN_JOY_LCD_SELECT] == 1) && currentMenu[LCDScreen].id != menuItemBatteryLevel.id && currentMenu[LCDScreen].id != menuItemCurrentProgram.id)
	{
		waitForLCDButtonRelease();
		/* If LCD is on the Autonomous menu screen, go to the direction selection screen */
		if (currentMenu == menuListAuton && currentMenu[LCDScreen].id != menuItemAutonGoBack.id && currentMenu[LCDScreen].isDirectional)
		{
			selectedProgram = &currentMenu[LCDScreen];
			reconfigureMenu(menuListSides, 1, 0, MENU_LIST_SIDES_LENGTH - 1);
		}
		else if (currentMenu == menuListSides && currentMenu[LCDScreen].id != menuItemSideGoBack.id)
		{
			autonomousSide = (currentMenu[LCDScreen].id == menuItemSideLeft.id) ? SIDE_LEFT : SIDE_RIGHT;
			reconfigureMenu(menuListColors, 1, 0, MENU_LIST_COLORS_LENGTH - 1);
		}
		/* If the current menu Item is redirecting to the autonomous screen, go to the menu screen */
		else if (currentMenu[LCDScreen].id == menuItemSideGoBack.id || currentMenu[LCDScreen].id == menuItemGoToAuton.id)
		{
			reconfigureMenu(menuListAuton, 1, 0, MENU_LIST_AUTON_LENGTH - 1);
		}
		else if (currentMenu[LCDScreen].id == menuItemColorGoBack.id)
		{
			reconfigureMenu(menuListSides, 1, 0, MENU_LIST_SIDES_LENGTH - 1);
		}
		/* If current screen is the menu Item for going back to main screen... */
		else if (currentMenu[LCDScreen].id == menuItemAutonGoBack.id || currentMenu[LCDScreen].id == menuItemPIDGoBack.id || currentMenu[LCDScreen].id == menuItemMotorCheckGoBack.id)
		{
			LCDScreenMax = MENU_LIST_MAIN_LENGTH - 1;
			/* If in hardcoded competition mode, allow competition mode switch option */
			currentMenu = menuListMain;
			if (isCompetitionMode)
			{
#ifdef competitionEnabled
				LCDScreenMin = menuItemGoToAuton.idx;
#else
				LCDScreenMin = menuItemSwitchCompetitionMode.idx;
#endif
			}
			else LCDScreenMin = menuItemUserControl.idx;
			LCDScreen = menuItemGoToAuton.idx;
		}
		/* If the current screen is the reset gyro screen, reset the gyro and notify the user */
		else if (currentMenu[LCDScreen].id == menuItemResetGyro.id)
		{
			SensorValue[gyro1] = 0;
			SensorValue[gyro2] = 0;
			displayLCDCenteredString(0, "Gyro Reset!");
			clearLCDLine(1);
			wait1Msec(1000);
		}
		/* If the current screen is the switch mode screen... */
		else if (currentMenu[LCDScreen].id == menuItemSwitchCompetitionMode.id)
		{
			isCompetitionMode = !isCompetitionMode;
			if (!isCompetitionMode) LCDAction = "Start";
			else LCDAction = "Select";
			displayLCDCenteredString(0, "Mode Switched!");
			clearLCDLine(1);
			wait1Msec(1000);

			/* If it is currently in competition mode, make usercontrol and PID mode unavailable.
			If hardcoded competition mode, don't show the switch comeptition mode option. */
			if (isCompetitionMode)
			{
				currentMenu = menuListMain;
#ifdef competitionEnabled
				LCDScreenMin = menuItemGoToAuton.idx;
#else
				LCDScreenMin = menuItemSwitchCompetitionMode.idx;
#endif
			}
			else
			{
				LCDScreenMin = menuItemUserControl.idx;
				stopTasks();
				startUp();
			}
		}
		else if (currentMenu[LCDScreen].id == menuItemPIDMode.id)
		{
			reconfigureMenu(menuListPID, 1, 0, MENU_LIST_PID_LENGTH - 1);
		}
		else if (currentMenu[LCDScreen].id == menuItemMotorCheck.id)
		{
			reconfigureMenu(menuListMotorCheck, 1, 0, MENU_LIST_MOTOR_CHECK_LENGTH - 1);
		}
		else
		{
			/* If a direction menu item is pressed, update the direction variable. */
			if (currentMenu[LCDScreen].id ==  menuItemColorBlue.id) autonomousColor = COLOR_BLUE;
			else if (currentMenu[LCDScreen].id ==  menuItemColorRed.id) autonomousColor = COLOR_RED;
			else selectedProgram = &currentMenu[LCDScreen];

			LCDScreenMax = MENU_LIST_MAIN_LENGTH - 1;
			LCDScreen = menuItemCurrentProgram.idx;
			currentMenu = menuListMain;

			/* If it is currently in competition mode, make usercontrol and PID mode unavailable.
			If hardcoded competition mode, don't show the switch comeptition mode option. */
			if (isCompetitionMode)
			{
#ifdef competitionEnabled
				LCDScreenMin = menuItemGoToAuton.idx;
#else
				LCDScreenMin = menuItemSwitchCompetitionMode.idx;
#endif
			}
			else
			{
				LCDScreenMin = menuItemUserControl.idx;
				stopTasks();
				startUp();
			}
		}
	}
}


task loadLCDScreen() // Task responsible for keeping LCD Screen running.
{
	while (true)
	{
		displayProgram();
	}
}


char* ConvertIntegerToString(long num)
{
	string s = "";
	sprintf(s, "%d", num);
	return s;
}


int waitForJoystickButtonPress() // Gets joystick input and returns the index of the current button pressed.
{
	int buttons[12] = { Btn5D, Btn5U, Btn6D, Btn6U, Btn7U, Btn7D, Btn7R, Btn7L, Btn8R, Btn8D, Btn8U, Btn8L };
	ubyte count = 0;
	ubyte i = 0;
	ubyte buttonPressed;

	while (true)
	{
		count = 0;
		for (i = 0; i < 12; i++)
		{
			if (vexRT[buttons[i]] == 1)
			{
				count++;
				buttonPressed = i;
			}
		}
		if (count == 1) return buttons[buttonPressed];
	}
}


void waitForJoystickButtonRelease() // Waits for all joystick buttons to be released.
{
	int buttons[12] = { Btn5D, Btn5U, Btn6D, Btn6U, Btn7U, Btn7D, Btn7R, Btn7L, Btn8R, Btn8D, Btn8U, Btn8L };
	bool buttonReleased = true;
	while (true)
	{
		buttonReleased = true;
		for (int i = 0; i < 12; i++)
		{
			if (vexRT[buttons[i]] == 1) buttonReleased = false;
		}
		if (buttonReleased == true) break;
	}
}



void ResetAllSensors()
{
	int sensorPorts[] = { in1, in2, in3, in4, in5, in6, in7, in8, dgtl1,
		dgtl2, dgtl3, dgtl4, dgtl5, dgtl6, dgtl7, dgtl8,
		dgtl9, dgtl10, dgtl11, dgtl12 };
	for (int i = 0; i < 20; i++)
	{
		SensorValue[sensorPorts[i]] = 0;
	}
}


















void pre_auton()
{
	bStopTasksBetweenModes = true; // Extremely glitchy when disabled
	populateMenuItems(); // Update menuItem arrays
	stopTasks(); // Stop all non-main tasks

	/* enable competition mode by default if flag is set */
#ifdef competitionEnabled
	isCompetitionMode = true;
#endif

	if (isLCDEnabled)
	{
		selectedProgram = NULL;
		/* If not hardcoded competition mode, allow User Control option */
#ifndef competitionEnabled
		LCDScreenMin = menuItemUserControl.id;
#else
		LCDScreenMin = menuItemGoToAuton.id;
#endif

		LCDScreenMax = menuItemBatteryLevel.id;
		bLCDBacklight = true; // Turn on LCD Backlight

		/* If not competition mode, set action string to "Start", stop all tasks, and restart LCD Screen */
		if (!isCompetitionMode)
		{
			LCDAction = "<     Start    >";
			selectedProgram = startupLCDProgram;
			LCDScreen = menuItemUserControl.id;
			stopTasks();
			startUp();
		}
		else
		{
			LCDAction = "<    Select    >";
			LCDScreen = menuItemGoToAuton.id;
		}

		displayLCDCenteredString(0, "Daud Jaan");
		displayLCDCenteredString(1, "99 Triple X");
		wait1Msec(1500);
#ifndef competitionEnabled

		/* Password Lock */
		if (PASSWORD_ENABLED)
		{
			bool correctPassword = false;
			ubyte incorrectAttempts = 3;
			while (!correctPassword)
			{
				displayLCDCenteredString(0, "Enter Password");
				displayLCDCenteredString(1, "");
				int correctCode[5] = { Btn5D, Btn6U, Btn7D, Btn6U, Btn8R };
				int code[5];

				/* Get joystick inputs from user and store in array */
				for (int i = 0; i < 5; i++)
				{
					waitForJoystickButtonPress();
					code[i] = waitForJoystickButtonPress();
					waitForJoystickButtonRelease();
					displayLCDString(1, 6 + i, "*");
				}

				correctPassword = true;

				/* Check if entered code matches password */
				for (ubyte i = 0; i < 5; i++)
				{
					if (code[i] != correctCode[i]) correctPassword = false;
				}

				/* If incorrect password, decrement attempt number and notify user */
				if (!correctPassword)
				{
					incorrectAttempts--;
					displayLCDCenteredString(0, "Wrong Password");
					displayLCDCenteredString(1, "**************");
					wait1Msec(1500);

					string attempts = "";
					sprintf(attempts, "%d", incorrectAttempts);
					attempts += " Attempts Left";
					displayLCDCenteredString(0, "You Have");
					displayLCDCenteredString(1, attempts);
					wait1Msec(1500);

					/* If no more attempts left, shutdown Robot. */
					if (incorrectAttempts == 0)
					{
						displayLCDCenteredString(0, "Bye Bye");
						displayLCDCenteredString(1, "");
						wait1Msec(2000);
						stopAllTasks();
						stopTask(loadLCDScreen);
						stopTask(main);
					}
				}
			}
		}
#endif

		ResetAllSensors();
		stopTask(loadLCDScreen);
		startTask(loadLCDScreen);

		SensorValue[gyro1] = sensorNone;
		SensorValue[gyro2] = sensorNone;
		wait1Msec(1000);
		SensorValue[gyro1] = sensorGyro;
		SensorValue[gyro2] = sensorGyro;
		wait1Msec(2000);

	}
}























/*---------------------------------------------------------------------------*/
/*																			 */
/*								Autonomous Task	 							 */
/*																			 */
/*---------------------------------------------------------------------------*/


float leftDriveMultiplier = (10.0/10.0);
float rightDriveMultiplier = (10.0/10.0);
short gyroSoftOffset = 0;
ubyte numOfInternalCones = 0;


short getArmSensorValue() { return (SensorValue[potentiometerArm] + ARM_POTENTIOMETER_OFFSET) * ARM_POTENTIOMETER_MULTIPLIER; }
short getMini4BarSensorValue() { return (SensorValue[potentiometerMini4Bar] + MINI_4_BAR_POTENTIOMETER_OFFSET) * MINI_4_BAR_POTENTIOMETER_MULTIPLIER; }
short getMoGoLiftSensorValue() { return (SensorValue[potentiometerMoGoLift] + MOGO_LIFT_POTENTIOMETER_OFFSET) * MOGO_LIFT_POTENTIOMETER_MULTIPLIER; }
short getGyroSensorValue() { return (SensorValue[gyro1] + SensorValue[gyro2] * (-1)) / 2; }
short getDriveLeftSensorValue() { return SensorValue[encoderDriveLeft] * DRIVE_ENCODER_LEFT_MULTIPLIER; }
short getDriveRightSensorValue() { return SensorValue[encoderDriveRight] * DRIVE_ENCODER_RIGHT_MULTIPLIER; }

short correctArmGoalPoint(short goalPoint) { return goalPoint * ARM_POTENTIOMETER_MULTIPLIER; }
short correctDriveLeftGoalPoint(short goalPoint) { return goalPoint * DRIVE_ENCODER_LEFT_MULTIPLIER; }
short correctDriveRightGoalPoint(short goalPoint) { return goalPoint * DRIVE_ENCODER_RIGHT_MULTIPLIER; }
short correctMini4BarGoalPoint(short goalPoint) { return goalPoint * MINI_4_BAR_POTENTIOMETER_MULTIPLIER; }
short correctMoGoLiftGoalPoint(short goalPoint) { return goalPoint * MOGO_LIFT_POTENTIOMETER_MULTIPLIER; }
short correctGyroGoalPoint(short goalPoint)
{
	goalPoint += gyroSoftOffset;
	if (goalPoint < -3600) goalPoint += 3600;
	else if (goalPoint > 3600) goalPoint -= 3600;

	return goalPoint * GYRO_MULTIPLIER;
}

byte getDriveLeftMotorPower() { return motor[motorDriveLeftBack]; }
byte getDriveRightMotorPower() { return motor[motorDriveRightFrontBack]; }
byte getArmMotorPower() { return motor[motorArmLeftBottom]; }
byte getMini4BarMotorPower() { return motor[motorMini4Bar]; }
byte getMoGoLiftMotorPower() { return motor[motorMoGoLiftLeft]; }
byte getGoliathMotorPower() { return motor[motorGoliath]; }


void resetGyro(short leftSidedOffset)
{
	if (autonomousSide == SIDE_LEFT) gyroSoftOffset = leftSidedOffset;
	else if (autonomousSide == SIDE_RIGHT) gyroSoftOffset = leftSidedOffset * (-1);
	SensorValue[gyro1] = 0;
	SensorValue[gyro2] = 0;
}


void setDriveMotorPower(int leftMotorPower, int rightMotorPower) // Set Drive motor power with seperate power for each side
{
	motor[motorDriveRightFrontBack] = rightMotorPower * rightDriveMultiplier;

	motor[motorDriveLeftFront] = leftMotorPower * leftDriveMultiplier;
	motor[motorDriveLeftBack] = leftMotorPower * leftDriveMultiplier;
}

void setDriveMotorPower(int motorPower) // Set equal drive motor power for all motors
{
	setDriveMotorPower(motorPower, motorPower);
}

void setArmMotorPower(int motorPower) // Set arm motor power
{
	motor[motorArmRightTop] = motorPower;
	motor[motorArmLeftBottom] = motorPower;
	motor[motorArmRightBottomAndLeftTop] = motorPower;
}


void setGoliathMotorPower(int motorPower) // Set individual claw motor power
{
	motor[motorGoliath] = motorPower;
}

void setMini4BarMotorPower(int motorPower)
{
	motor[motorMini4Bar] = motorPower;
}

void setMoGoLiftMotorPower(int motorPower)
{
	motor[motorMoGoLiftLeft] = motorPower;
	motor[motorMoGoLiftRight] = motorPower;
}



byte SlewRate(int lastPower, int newPower, float rate, int maxSpeedDifference) // Prevent large accelerations by reducing speed change if greater than MAX_SPEED_DIFFERENCE
{
	int speedDifference = lastPower - newPower;
	if (abs(speedDifference) < maxSpeedDifference)
	{
		return newPower;
	}
	else
	{
		return (lastPower - speedDifference * rate);
	}
}


bool autonomousReady = true;

void waitUntilReady()
{
	wait1Msec(10);
	while (!autonomousReady) { }
}

/* Perform timed action for given amount of time with individual motor powers */
void actionTimed(Action action, short time, byte leftMotorPower, byte rightMotorPower)
{
	autonomousReady = false;

	clearTimer(T1);
	if (action == A_DRIVE) setDriveMotorPower(leftMotorPower, rightMotorPower);
	else if (action == A_ARM) setArmMotorPower(leftMotorPower);
	else if (action == A_GOLIATH) setGoliathMotorPower(leftMotorPower);
	else if (action == A_MINI_4_BAR) setMini4BarMotorPower(leftMotorPower);
	else if (action == A_MOGO_LIFT) setMoGoLiftMotorPower(leftMotorPower);

	while (time1[T1] <= time) { }

	if (action == A_DRIVE) setDriveMotorPower(0,0);
	else if (action == A_ARM) setArmMotorPower(0);
	else if (action == A_GOLIATH) setGoliathMotorPower(0);
	else if (action == A_MINI_4_BAR) setMini4BarMotorPower(0);
	else if (action == A_MOGO_LIFT) setMoGoLiftMotorPower(0);


	autonomousReady = true;
}

/* Perform timed action for given amount of time with equal motor powers */
void actionTimed(Action action, int time, int motorPower)
{
	actionTimed(action, time, motorPower, motorPower);
}



/* Perform action until sensor passes given value */
void actionUntilAtGoalPoint(Action action, short goalPoint, byte motorPower)
{
	autonomousReady = false;

	byte multiplier = 1;

	if (SensorValue[encoderDriveLeft] > goalPoint ||
		getArmSensorValue() > goalPoint ||
	getMini4BarSensorValue() > goalPoint ||
	getMoGoLiftSensorValue() > goalPoint) multiplier = -1;

	motorPower = abs(motorPower) * multiplier;

	if (action == A_DRIVE)
	{
		setDriveMotorPower(motorPower, motorPower);
		while (SensorValue[encoderDriveLeft] * multiplier < goalPoint * multiplier) { }
	}
	else if (action == A_ARM)
	{
		setArmMotorPower(motorPower);
		while (getArmSensorValue() * multiplier < goalPoint * multiplier) { }
	}
	else if (action == A_MINI_4_BAR)
	{
		setArmMotorPower(motorPower);
		while (getMini4BarSensorValue() * multiplier < goalPoint * multiplier) { }
	}
	else if (action == A_MOGO_LIFT)
	{
		setMoGoLiftMotorPower(motorPower);
		while (getMoGoLiftSensorValue() * multiplier < goalPoint * multiplier) { }
	}

	if (action == A_DRIVE) setDriveMotorPower(0);
	else if (action == A_ARM) setArmMotorPower(0);
	else if (action == A_MOGO_LIFT) setMoGoLiftMotorPower(0);
	else if (action == A_MINI_4_BAR) setMini4BarMotorPower(0);

	autonomousReady = true;
}


/* Perform action until sensor value is greater than given value with individual motor power */
void actionUntilOverGoalPoint(Action action, short goalPoint, byte leftMotorPower, byte rightMotorPower)
{
	autonomousReady = false;

	if (action == A_DRIVE)
	{
		SensorValue[encoderDriveLeft] = 0;
		setDriveMotorPower(leftMotorPower, rightMotorPower);
		while (SensorValue[encoderDriveLeft] < goalPoint) { }
	}
	else if (action == A_ARM)
	{
		setArmMotorPower(leftMotorPower);
		while (getArmSensorValue() < goalPoint)	{ }
	}
	else if (action == A_MINI_4_BAR)
	{
		setMini4BarMotorPower(leftMotorPower);
		while (getMini4BarSensorValue() < goalPoint) { }
	}
	else if (action == A_MOGO_LIFT)
	{
		setMoGoLiftMotorPower(leftMotorPower);
		while (getMoGoLiftSensorValue() < goalPoint) { }
	}

	if (action == A_DRIVE) setDriveMotorPower(0);
	else if (action == A_ARM) setArmMotorPower(0);
	else if (action == A_MOGO_LIFT) setMoGoLiftMotorPower(0);
	else if (action == A_MINI_4_BAR) setMini4BarMotorPower(0);

	autonomousReady = true;
}


/* Perform action until sensor value is over given value with equal motor power */
void actionUntilOverGoalPoint(Action action, short goalPoint, byte motorPower)
{
	actionUntilOverGoalPoint(action, goalPoint, motorPower, motorPower);
}


/* Perform action until sensor value is less than given value with individual motor power */
void actionUntilUnderGoalPoint(Action action, short goalPoint, byte leftMotorPower, byte rightMotorPower)
{
	autonomousReady = false;

	if (action == A_DRIVE)
	{
		SensorValue[encoderDriveLeft] = 0;
		setDriveMotorPower(leftMotorPower, rightMotorPower);
		while (SensorValue[encoderDriveLeft] > goalPoint) { }
	}
	else if (action == A_ARM)
	{
		setArmMotorPower(leftMotorPower);
		while (getArmSensorValue() > goalPoint)	{ }
	}
	else if (action == A_MINI_4_BAR)
	{
		setMini4BarMotorPower(leftMotorPower);
		while (getMini4BarSensorValue() > goalPoint) { }
	}
	else if (action == A_MOGO_LIFT)
	{
		setMoGoLiftMotorPower(leftMotorPower);
		while (getMoGoLiftSensorValue() > goalPoint) { }
	}

	if (action == A_DRIVE) setDriveMotorPower(0);
	else if (action == A_ARM) setArmMotorPower(0);
	else if (action == A_MOGO_LIFT) setMoGoLiftMotorPower(0);
	else if (action == A_MINI_4_BAR) setMini4BarMotorPower(0);

	autonomousReady = true;
}

/* Perform action until sensor value is less than given value with equal motor power */
void actionUntilUnderGoalPoint(Action action, short goalPoint, byte motorPower)
{
	actionUntilUnderGoalPoint(action, goalPoint, motorPower, motorPower);
}





void drivePIDControl(short goalPoint, Mode mode, OnStall onStall)
{
	autonomousReady = false;

	leftDriveMultiplier = 1.0;
	rightDriveMultiplier = 1.0;

	float pGain = 0.1;
	float iGain = 0.1;
	float dGain = 8;

	goalPoint = getDriveLeftSensorValue() + correctDriveLeftGoalPoint(goalPoint);

	short error = goalPoint - getDriveLeftSensorValue();

	int newPower = 0;
	int errorSum = 0;
	short errorDifference = 0;
	int timeInitialOnStall = time1[T4];

	if (mode == MODE_ACCURATE || mode == MODE_MOGO)
	{
		if (mode == MODE_ACCURATE)
		{
			leftDriveMultiplier = (1.0);
			rightDriveMultiplier = (1.0);

			//pGain = (0.55);
			//iGain = (0.01);
		//	dGain = (3.2);
		}
		else if (mode == MODE_MOGO)
		{
//			pGain = (0.55);
//			iGain = (0.01);
//			dGain = (3.2);
			//pGain = 0.55;
			//iGain = 0.005;
			//dGain = 5.0;
			//leftDriveMultiplier = (2.0/3.0);
			//rightDriveMultiplier = (2.0/3.0);
		}

		/*while (errorDifference == 0)
		{
			errorDifference = error - (goalPoint - getDriveLeftSensorValue());
			error = goalPoint - getDriveLeftSensorValue();
			newPower += 5;
			if (error != 0) setDriveMotorPower(newPower * (error / abs(error)) );
			wait1Msec(30);
		}

		minPower = newPower - 10;*/

		if (mode == MODE_ACCURATE)
		{
			while (abs(error) > 220 && ( (time1[T4] - timeInitialOnStall < 1000 && onStall == ON_STALL_EXIT) || onStall == ON_STALL_NOTHING) )
			{
				errorDifference = error - (goalPoint - getDriveLeftSensorValue());
				error = goalPoint - getDriveLeftSensorValue();
				setDriveMotorPower(127 * error / abs(error));

				if (errorDifference != 0) timeInitialOnStall = time1[T4];
			}
		}
		else if (mode == MODE_MOGO)
		{
			while (abs(error) > 220 && ( (time1[T4] - timeInitialOnStall < 1000 && onStall == ON_STALL_EXIT) || onStall == ON_STALL_NOTHING) )
			{
				errorDifference = error - (goalPoint - getDriveLeftSensorValue());
				if (errorDifference != 0) timeInitialOnStall = time1[T4];

				error = goalPoint - getDriveLeftSensorValue();
				setDriveMotorPower( SlewRate(motor[motorDriveLeftBack], 127 * 0.67 * error / abs(error), 0.05, 5) );
			}
		}

		int timeInitialPID = time1[T4];
		while (time1[T4] - timeInitialPID < 150 && ( (time1[T4] - timeInitialOnStall < 1000 && onStall == ON_STALL_EXIT) || onStall == ON_STALL_NOTHING) )
		{
			errorDifference = error - (goalPoint - getDriveLeftSensorValue());
			error = goalPoint - getDriveLeftSensorValue();
			errorSum += error / 10.0;

			if ((abs(errorDifference) > 4 && mode == MODE_ACCURATE) || (abs(errorDifference) > 2 && mode == MODE_MOGO) || (errorSum > 0 && error < 0) || (errorSum < 0 && error > 0) || abs(error) < 14) errorSum = 0;
			if ( !(errorDifference == 0 && abs(newPower) >= 127.0) ) timeInitialOnStall = time1[T4];

			if (abs(error) >= 15) timeInitialPID = time1[T4];

			/* Prevent wind-up. Set maximum integral gain to 127 power. */
			if (errorSum * iGain > 127.0) errorSum = 127.0 / iGain;
			else if (errorSum * iGain < -127.0) errorSum = -127.0 / iGain;


			//if (abs(errorDifference) > 9) newPower = error * pGain;
			//pPower = error * pGain;
			//iPower = errorSum * iGain;
			//dPower = -errorDifference * dGain;

			//if (abs(error) >= 30) sPower = -sGain / error;
			newPower = error * pGain + errorSum * iGain - errorDifference * dGain;

			if (mode == MODE_MOGO && newPower < 0) newPower = newPower * 2.0 / 3.0;

			//if (abs(newPower) < abs(minPower) && abs(error) >= 15) newPower = abs(minPower) * (error / abs(error) );

			//if (abs(error) > 80) newPower = SlewRate(motor[motorDriveLeftBack], newPower, 0.03, 5);
			setDriveMotorPower(newPower);

			wait1Msec(5);
		}
	}
	else if (mode == MODE_FAST)
	{
		pGain = (0.25);
		iGain = (0.001);
		dGain = (0.5);

		int timeInitialOnStall = time1[T4];

		while (abs(error) >= 15 && ( (time1[T4] - timeInitialOnStall < 1000 && onStall == ON_STALL_EXIT) || onStall == ON_STALL_NOTHING) )
		{
			errorDifference = error - (goalPoint - getDriveLeftSensorValue());
			error = goalPoint - getDriveLeftSensorValue();
			errorSum += error;

			if (abs(error) < 15) errorSum = 0;
			if ( !(errorDifference == 0 && abs(newPower) >= 127.0) ) timeInitialOnStall = time1[T4];

			if (error > 0) newPower = 20 + error * pGain + errorSum * iGain - errorDifference * dGain;
			else if (error < 0) newPower = -20 + error * pGain + errorSum * iGain - errorDifference * dGain;

			/* Prevent wind-up. Set maximum integral gain to 127 power. */
			if (newPower > 127.0) errorSum = (127.0 - error * pGain + errorDifference * dGain) * (1.0 / iGain);
			else if (newPower < -127.0) errorSum = (-127.0 - error * pGain + errorDifference * dGain) * (1.0 / iGain);

			setDriveMotorPower(newPower, newPower);

			wait1Msec(25);
		}
	}
	setDriveMotorPower(0,0);
	autonomousReady = true;
}

/* Drive for specified amount of time while maintaining direction */
void gyroDrive(byte power, int time, short deg)
{
	autonomousReady = false;

	deg *= 10;
	float pGain = (500.0/1000.0);
	short error = 0;

	clearTimer(T1);
	while (time1[T1] < time)
	{
		error = getGyroSensorValue() - deg;
		if (getGyroSensorValue() > deg)
		{
			setDriveMotorPower( power - error * pGain, power );
		}
		else if (getGyroSensorValue() < deg)
		{
			setDriveMotorPower( power, power - error * pGain );
		}
		else
		{
			setDriveMotorPower(power);
		}
	}

	autonomousReady = true;
}



/* Face a certain bearing */
void gyroFace(short degrees)
{
	autonomousReady = false;

	degrees = correctGyroGoalPoint(degrees);
	degrees *= 10;
	int undershoot = 160;
	//degrees = (getGyroSensorValue() - degrees * 10) / 10;
	short error = degrees - getGyroSensorValue();
	byte left = 0, right = 0;
	if (degrees < 0){left = -1; right = 1;}
	else if (degrees > 0){left = 1; right = -1; }

	if (abs(error) > undershoot)
	{
		if (error > 0)
		{
			while (degrees - undershoot - getGyroSensorValue() > 0)
			{
				setDriveMotorPower(127 * left, 127 * right);
			}
		}
		else if (error < 0)
		{
			while (degrees + undershoot - getGyroSensorValue() < 0)
			{
				setDriveMotorPower(127 * left, 127 * right);
			}
		}
	}
	else if (abs(error) < undershoot)
	{
		if (error > 0)
		{
			while (degrees - getGyroSensorValue() > 0)
			{
				setDriveMotorPower(50 * left, 50 * right);
			}
		}
		else if (error < 0)
		{
			while (degrees - getGyroSensorValue() < 0)
			{
				setDriveMotorPower(50 * left, 50 * right);
			}
		}
	}

	setDriveMotorPower((127*left*-1)/9, (127*right*-1)/9);



	wait1Msec(250);
	setDriveMotorPower(0,0);

	/*	if (degrees - getGyroSensorValue() > 50)
	{
	while (degrees - getGyroSensorValue() > 0)
	{
	setDriveMotorPower(90 * left, 90 * right);
	}
	}
	else if (degrees - getGyroSensorValue() < -50)
	{
	while (degrees - getGyroSensorValue() < 0)
	{
	setDriveMotorPower(90 * left, 90 * right);
	}
	}

	setDriveMotorPower((127*left*-1)/9, (127*right*-1)/9);



	wait1Msec(50);
	setDriveMotorPower(0,0);*/

	autonomousReady = true;
}



/* Face an absolute directional bearing */
void gyroPIDControl(short goalPoint, Mode mode, OnStall onStall)
{
	if (mode == MODE_ACCURATE)
	{
		leftDriveMultiplier = 1.0;
		rightDriveMultiplier = 1.0;
	}
	else if (mode == MODE_MOGO)
	{
		leftDriveMultiplier = 1.0;
		rightDriveMultiplier = 1.0;
	}

	float pGain = (1.5);
	float iGain = (0.01);
	float dGain = (20.0);

	autonomousReady = false;

	goalPoint *= 10; // Convert degree format to gyro format
	goalPoint = correctGyroGoalPoint(goalPoint);

	short error = goalPoint - getGyroSensorValue();
	int newPower = 0;
	const int minPower = 0;
	int errorSum = 0;
	short errorDifference = 0;
	const ubyte errorMargin = 10;
	int timeInitialPID = time1[T4];
	int timeInitialOnStall = time1[T4];

	while (time1[T4] - timeInitialPID < 150 && ( (time1[T4] - timeInitialOnStall < 1000 && onStall == ON_STALL_EXIT) || onStall == ON_STALL_NOTHING) )
	{
		errorDifference = error - (goalPoint  - getGyroSensorValue());
		error = goalPoint  - getGyroSensorValue();
		errorSum += error / 10.0;

		if (abs(errorDifference) > 20) errorSum = 0;

		if ( !(errorDifference == 0 && abs(newPower) >= 127.0) ) timeInitialOnStall = time1[T4];

		if (abs(error) < 19) errorSum = 0;
		if (abs(error) >= 19) timeInitialPID = time1[T4];

		/* Prevent wind-up. Set maximum integral gain to 127 power. */
		if (errorSum * iGain > 127.0) errorSum = 127.0 / iGain;
		else if (errorSum * iGain < -127.0) errorSum = -127.0 / iGain;

		if (abs(error) < 19) newPower = 0;
		else
		{
			if (abs(errorDifference) > 20) newPower = error * pGain;
			else newPower = newPower = error * pGain + errorSum * iGain - errorDifference * dGain;
		}

		/* Set motor power to minimum required to move if lower than minimum */
		//if (newPower > -minPower && error < 0) newPower = -minPower;
		//else if (newPower < minPower && error > 0) newPower = minPower;

		if (mode == MODE_MOGO)
		{
			if (newPower > 85) newPower = 85;
			else if (newPower < -85) newPower = -85;
		}
		setDriveMotorPower(newPower * (-1), newPower);

		wait1Msec(5);

		//if (abs(getGyroSensorValue() - goalPoint) < 6 && abs(newPower) < 10) wait1Msec(100);
	}
	setDriveMotorPower(0,0);

	autonomousReady = true;
}

/* Rotate from current bearing */
void gyroRotate(short deg)
{
	autonomousReady = false;
	short goalPoint = (getGyroSensorValue() + deg * 10);
	while (goalPoint > 3600) goalPoint -= 3600;
	while (goalPoint < -3600) goalPoint += 3600;
	gyroFace(goalPoint);
}



void armPIDControl(short goalPoint, WaitForAction stopWhenMet, OnStall onStall)
{
	float pGain = (2.8/10.0);
	float iGain = (3.0/1000.0);
	float dGain = (11.0/10.0);

	autonomousReady = false;

	goalPoint = correctArmGoalPoint(goalPoint);

	int errorSum = 0;
	short errorDifference = 0;
	short error = goalPoint - getArmSensorValue();
	int newPower = 0;

	int timeInitialPID = time1[T4];
	int timeInitialOnStall = time1[T4];

	while ( (time1[T4] - timeInitialPID < 300 || stopWhenMet == WAIT_NONE) && ( (time1[T4] - timeInitialOnStall < 1000 && onStall == ON_STALL_EXIT) || onStall == ON_STALL_NOTHING) )
	{
		errorDifference = error - (goalPoint - getArmSensorValue());
		error = goalPoint - getArmSensorValue();
		errorSum = errorSum + error / 10.0;

		if (abs(error) >= 50) timeInitialPID = time1[T4];
		if ( !(abs(errorDifference) < 5 && abs(newPower) >= 127.0) ) timeInitialOnStall = time1[T4];

		/* Prevent wind-up. Set max integral gain to max power. */
		if (errorSum * iGain > 127.0) errorSum = 127.0 / iGain;
		else if (errorSum * iGain < -127.0) errorSum = -127.0 / iGain;

		newPower = error * pGain + errorSum * iGain - errorDifference * dGain;

		setArmMotorPower(newPower);
		wait1Msec(15);
	}

	autonomousReady = true;
}




void mini4BarPIDControl(short goalPoint, WaitForAction stopWhenMet, OnStall onStall)
{
	float pGain = 0.3;
	float iGain = 0.0001;
	float dGain = 4;

	goalPoint = correctMini4BarGoalPoint(goalPoint);

	short error = goalPoint - getMini4BarSensorValue();
	int errorSum = 0;
	short errorDifference = 0;
	int timeInitialPID = time1[T4];
	int timeInitialOnStall = time1[T4];
	int newPower = 0;

	while ( (time1[T4] - timeInitialPID < 150 || stopWhenMet == WAIT_NONE) && ( (time1[T4] - timeInitialOnStall < 1000 && onStall == ON_STALL_EXIT) || onStall == ON_STALL_NOTHING) )
	{
		errorDifference = error - (goalPoint - getMini4BarSensorValue());
		error = goalPoint - getMini4BarSensorValue();
		errorSum += error;

		if (abs(error) > 50) timeInitialPID = time1[T4];
		if ( !(abs(errorDifference) < 5 && abs(newPower) >= 127.0) ) timeInitialOnStall = time1[T4];

		if (abs(error) <= 50 && goalPoint > correctMini4BarGoalPoint(MINI_4_BAR_POTENTIOMETER_RETRACTED_VALUE + 200) ) errorSum = -25.0 / iGain;
		else if (abs(error) <= 50) errorSum = 0;

		newPower = error * pGain + errorSum * iGain - errorDifference * dGain;
		setMini4BarMotorPower(newPower);
		wait1Msec(1);
	}
	setMini4BarMotorPower(-20);
}


void startTMini4Bar(short goalPoint, WaitForAction stopWhenMet, OnStall onStall);

void mini4BarRetract(WaitForAction stopWhenMet, OnStall onStall)
{
	startTMini4Bar(MINI_4_BAR_POTENTIOMETER_RETRACTED_VALUE, stopWhenMet, onStall);
}

void mini4BarExtend(WaitForAction stopWhenMet, OnStall onStall)
{
	startTMini4Bar(MINI_4_BAR_POTENTIOMETER_EXTENDED_VALUE, stopWhenMet, onStall);
}

void mini4BarParallel(WaitForAction stopWhenMet, OnStall onStall)
{
	startTMini4Bar(MINI_4_BAR_POTENTIOMETER_PARALLEL_VALUE, stopWhenMet, onStall);
}



void moGoRetract(OnStall onStall)
{
	int timeInitial = time1[T4];
	int timeInitialOnStall = time1[T4];
	int error = correctMoGoLiftGoalPoint(MOGO_LIFT_POTENTIOMETER_RETRACTED_VALUE) - getMoGoLiftSensorValue();
	int errorDifference = 0;

	while (time1[T4] - timeInitial < 150  && ( (time1[T4] - timeInitialOnStall < 1000 && onStall == ON_STALL_EXIT) || onStall == ON_STALL_NOTHING) )
	{
		errorDifference = error - (correctMoGoLiftGoalPoint(MOGO_LIFT_POTENTIOMETER_RETRACTED_VALUE) - getMoGoLiftSensorValue());
		error = correctMoGoLiftGoalPoint(MOGO_LIFT_POTENTIOMETER_RETRACTED_VALUE) - getMoGoLiftSensorValue();
		setMoGoLiftMotorPower(-127);
		if (abs(errorDifference) > 5) timeInitialOnStall = time1[T4];
		if (getMoGoLiftSensorValue() > correctMoGoLiftGoalPoint(MOGO_LIFT_POTENTIOMETER_RETRACTED_VALUE)) timeInitial = time1[T4];
		wait1Msec(20);
	}
	setMoGoLiftMotorPower(0);
}

void moGoExtend(OnStall onStall)
{
	float dGain = 2.0;

	short error = correctMoGoLiftGoalPoint(MOGO_LIFT_POTENTIOMETER_EXTENDED_VALUE) - getMoGoLiftSensorValue();
	short errorDifference = 0;
	int timeInitialOnStall = time1[T4];

	while (getMoGoLiftSensorValue() < correctMoGoLiftGoalPoint(MOGO_LIFT_POTENTIOMETER_EXTENDED_VALUE) && ( (time1[T4] - timeInitialOnStall < 1000 && onStall == ON_STALL_EXIT) || onStall == ON_STALL_NOTHING) )
	{
		errorDifference = error - (correctMoGoLiftGoalPoint(MOGO_LIFT_POTENTIOMETER_EXTENDED_VALUE) - getMoGoLiftSensorValue());
		error = correctMoGoLiftGoalPoint(MOGO_LIFT_POTENTIOMETER_EXTENDED_VALUE) - getMoGoLiftSensorValue();
		if (abs(errorDifference) > 5) timeInitialOnStall = time1[T4];

		setMoGoLiftMotorPower(50 - dGain * abs(errorDifference) );
		wait1Msec(20);
	}
	setMoGoLiftMotorPower(0);
}




void moGoHalfway(OnStall onStall)
{

	float pGain = 0.08;
	float iGain = 0.0003;
	float dGain = 2.0;

	short error = correctMoGoLiftGoalPoint(MOGO_LIFT_POTENTIOMETER_HALFWAY_VALUE) - getMoGoLiftSensorValue();
	short errorDifference = 0;
	int errorSum = 0;
	int timeInitialPID = time1[T4];
	int timeInitialOnStall = time1[T4];
	int newPower = 0;

	while (time1[T4] - timeInitialPID < 150 && ( (time1[T4] - timeInitialOnStall < 1000 && onStall == ON_STALL_EXIT) || onStall == ON_STALL_NOTHING) )
	{
		errorDifference = error - (correctMoGoLiftGoalPoint(MOGO_LIFT_POTENTIOMETER_HALFWAY_VALUE) - getMoGoLiftSensorValue());
		error = correctMoGoLiftGoalPoint(MOGO_LIFT_POTENTIOMETER_HALFWAY_VALUE) - getMoGoLiftSensorValue();
		errorSum += error;

		if ( !(abs(errorDifference) < 5 && abs(newPower) >= 127.0)) timeInitialOnStall = time1[T4];
		if (abs(error) < 30) errorSum = 0;
		else if (abs(error) >= 30) timeInitialPID = time1[T4];

		newPower = error * pGain + errorSum * iGain - errorDifference * dGain;
		setMoGoLiftMotorPower(newPower);

		wait1Msec(5);
	}
	setMoGoLiftMotorPower(0);
}




/* Variables used by tasks */
short tDrivePIDGoalPoint = 0;
short tArmPIDGoalPoint = ARM_POTENTIOMETER_HIGH_GOAL_VALUE;
short tGyroPIDGoalPoint = 0;
short tMini4BarGoalPoint = MINI_4_BAR_POTENTIOMETER_EXTENDED_VALUE;
StateExtension tMoGoLiftGoalState = STATE_EXTENSION_EXTENDED;
Macro tMacroGoalPoint;

Mode tDriveMode;
Mode tGyroMode;

OnStall tDrivePIDOnStall;
OnStall tArmPIDOnStall;
OnStall tGyroPIDOnStall;
OnStall tMini4BarPIDOnStall;
OnStall tMoGoLiftPIDOnStall;

void MacroArmReady();
void MacroMoGoStackCone();

/*  */
WaitForAction waitForTArmPID = WAIT;
WaitForAction waitForTMini4BarPID = WAIT;

/* Status of Autonomous Tasks */
bool isTDriveReady = true;
bool isTMini4BarReady = true;
bool isTMoGoLiftReady = true;
bool isTArmReady = true;
bool isTGyroFaceReady = true;
bool isTGyroPIDReady = true;
bool isTMacroReady = true;





/* Task Hosts for PIDs */
task tDrivePIDControl()
{
	isTDriveReady = false;

	drivePIDControl(tDrivePIDGoalPoint, tDriveMode, tDrivePIDOnStall);

	isTDriveReady = true;
}


task tGyroPIDControl()
{
	isTGyroPIDReady = false;

	gyroPIDControl(tGyroPIDGoalPoint, tGyroMode, tDrivePIDOnStall);

	isTGyroPIDReady = true;
}

task tGyroFace()
{
	isTGyroFaceReady = false;

	gyroFace(tGyroPIDGoalPoint);

	isTGyroFaceReady = true;
}


task tArmPIDControl()
{
	isTArmReady = false;

	armPIDControl(tArmPIDGoalPoint, waitForTArmPID, tArmPIDOnStall);

	isTArmReady = true;
}


task tMini4Bar()
{
	isTMini4BarReady = false;

	mini4BarPIDControl(tMini4BarGoalPoint, waitForTMini4BarPID, tMini4BarPIDOnStall);

	isTMini4BarReady = true;
}

task tMoGoLift()
{
	isTMoGoLiftReady = false;

	if (tMoGoLiftGoalState == STATE_EXTENSION_EXTENDED) moGoExtend(tMoGoLiftPIDOnStall);
	else if (tMoGoLiftGoalState == STATE_EXTENSION_RETRACTED) moGoRetract(tMoGoLiftPIDOnStall);
	else if (tMoGoLiftGoalState == STATE_EXTENSION_HALFWAY) moGoHalfway(tMoGoLiftPIDOnStall);

	isTMoGoLiftReady = true;
}

task tMacro()
{
	isTMacroReady = false;

	if (tMacroGoalPoint == MACRO_ARM_READY) MacroArmReady();
	else if (tMacroGoalPoint == MACRO_MOGO_STACK_CONE) MacroMoGoStackCone();

	isTMacroReady = true;
}


/* Procedures for starting autonomous tasks */

void startTDrivePID(short goalPoint, Mode mode, OnStall onStall)
{
	stopTask(tDrivePIDControl);
	stopTask(tGyroFace);
	stopTask(tGyroPIDControl);
	tDrivePIDGoalPoint = goalPoint;
	tDriveMode = mode;
	tDrivePIDOnStall = onStall;
	startTask(tDrivePIDControl);
}

void startTArmPID(short goalPoint, WaitForAction stopWhenMet, OnStall onStall)
{
	stopTask(tArmPIDControl);
	tArmPIDGoalPoint = goalPoint;
	waitForTArmPID = stopWhenMet;
	tArmPIDOnStall = onStall;

	startTask(tArmPIDControl);
}


void startTGyroPID(short goalPoint, Mode mode, OnStall onStall)
{
	stopTask(tDrivePIDControl);
	stopTask(tGyroFace);
	stopTask(tGyroPIDControl);
	tGyroPIDGoalPoint = goalPoint;
	tGyroMode = mode;
	tGyroPIDOnStall = onStall;

	startTask(tGyroPIDControl);
}

void startTGyroFace(short goalPoint)
{
	stopTask(tDrivePIDControl);
	stopTask(tGyroFace);
	stopTask(tGyroPIDControl);
	tGyroPIDGoalPoint = goalPoint;
	startTask(tGyroFace);
}

void startTMini4Bar(short goalPoint, WaitForAction stopWhenMet, OnStall onStall)
{
	stopTask(tMini4Bar);
	tMini4BarGoalPoint = goalPoint;
	waitForTMini4BarPID = stopWhenMet;
	tMini4BarPIDOnStall = onStall;

	startTask(tMini4Bar);
}

void startTMoGoLift(StateExtension GoalState, OnStall onStall)
{
	stopTask(tMoGoLift);
	tMoGoLiftGoalState = GoalState;
	tMoGoLiftPIDOnStall = onStall;

	startTask(tMoGoLift);
}

void startTMacro(Macro macroGoalPoint)
{
	stopTask(tMacro);
	tMacroGoalPoint = macroGoalPoint;
	startTask(tMacro);
}

/* Procedures for waiting for tasks */

void waitForTDrive()
{
	wait1Msec(10);
	while (!isTDriveReady) { }
}

void waitForTArm()
{
	wait1Msec(10);
	while (!isTArmReady) { }
}


void waitForTGyroFace()
{
	wait1Msec(10);
	while (!isTGyroFaceReady) { }
}

void waitForTGyroPID()
{
	wait1Msec(10);
	while (!isTGyroPIDReady) { }
}

void waitForTMini4Bar()
{
	wait1Msec(10);
	while (!isTMini4BarReady) { }
}

void waitForTMoGoLift()
{
	wait1Msec(10);
	while (!isTMoGoLiftReady) { }
}

void waitForTMacro()
{
	wait1Msec(10);
	while (!isTMacroReady) { }
}

void waitForAllPIDTasks()
{
	wait1Msec(10);
	while (!isTArmReady) { }
	while (!isTDriveReady) { }
	while (!isTGyroFaceReady) { }
	while (!isTGyroPIDReady) { }
	while (!isTMini4BarReady) { }
	while (!isTMoGoLiftReady) { }
	while (!isTMacroReady) { }
}


/* Procedure for killing all autonomous tasks. */
void stopAllTPID()
{
	stopTask(tDrivePIDControl);
	stopTask(tArmPIDControl);
	stopTask(tGyroPIDControl);
	stopTask(tGyroFace);
	stopTask(tMini4Bar);
	stopTask(tMoGoLift);
	stopTask(tMacro);
}



void goliathIntake(byte power)
{
	autonomousReady = false;

	stopTask(tMini4Bar);
	stopTask(tArmPIDControl);
	startTMini4Bar(STATE_EXTENSION_EXTENDED, WAIT_NONE, ON_STALL_EXIT);
	while (getMini4BarSensorValue() < correctMini4BarGoalPoint(MINI_4_BAR_POTENTIOMETER_EXTENDED_VALUE + 200) ) { }
	startTArmPID(ARM_POTENTIOMETER_MIN_VALUE, WAIT, ON_STALL_EXIT);
	setGoliathMotorPower(power);
	wait1Msec(200);
	setGoliathMotorPower(GOLIATH_REST_POWER);
	stopTask(tArmPIDControl);
	startTArmPID(ARM_POTENTIOMETER_CONE_HEIGHT_VALUE + 200, WAIT, ON_STALL_EXIT);

	autonomousReady = true;
}

void goliathIntake()
{
	goliathIntake(GOLIATH_INTAKE_POWER);
}



void MacroArmReady()
{
	setArmMotorPower(127);
	while (getArmSensorValue() < ( (numOfInternalCones > 4) ? correctArmGoalPoint(ARM_POTENTIOMETER_CONE_STACK_INITIAL_VALUE + numOfInternalCones * ARM_POTENTIOMETER_CONE_MULTIPLIER + 200) : ARM_POTENTIOMETER_MIN_VALUE + 300 ) ) { }
	setArmMotorPower(0);
	startTMini4Bar(STATE_EXTENSION_EXTENDED, WAIT, ON_STALL_EXIT);
	waitForTMini4Bar();

	startTArmPID(ARM_POTENTIOMETER_CONE_HEIGHT_VALUE, WAIT_NONE, ON_STALL_EXIT);
	waitForTArm();
	setArmMotorPower(0);
}

void MacroMoGoStackCone()
{
	setArmMotorPower(-30);
	setGoliathMotorPower(50);
	wait1Msec(500);
	startTArmPID( (numOfInternalCones > 4) ? ARM_POTENTIOMETER_CONE_STACK_INITIAL_VALUE + numOfInternalCones * ARM_POTENTIOMETER_CONE_MULTIPLIER + 200 : ARM_POTENTIOMETER_MIN_VALUE + 100, WAIT, ON_STALL_EXIT);
	waitForTArm();
	startTMini4Bar(STATE_EXTENSION_RETRACTED, WAIT, ON_STALL_EXIT);
	waitForTMini4Bar();

	if (numOfInternalCones > 4) startTArmPID(ARM_POTENTIOMETER_CONE_STACK_INITIAL_VALUE + numOfInternalCones * ARM_POTENTIOMETER_CONE_MULTIPLIER + 200, WAIT, ON_STALL_EXIT);
	waitForTArm();

	setGoliathMotorPower(-50);
	wait1Msec(800);
	setGoliathMotorPower(50);
}





task playMissionImpossibleMusic;

task autonomous()
{
	clearTimer(T4);
	startTask(playMissionImpossibleMusic);
	if (isLCDEnabled)
	{
		if (getTaskState(loadLCDScreen) == taskStateStopped) startTask(loadLCDScreen);
		displayLCDCenteredString(0, "Daud Jaan");
		displayLCDCenteredString(1, (*selectedProgram).name);
	}
	if ( (*selectedProgram).id == menuItemAuton22P.id || (*selectedProgram).id == menuItemAuton7P.id || (*selectedProgram).id == menuItemAuton9P.id || (*selectedProgram).id == menuItemAuton12P.id || (*selectedProgram).id == menuItemAuton24P.id || (*selectedProgram).id == menuItemAuton14P.id)
	{
		setGoliathMotorPower(40);
		setArmMotorPower(-40);
		wait1Msec(300);
		setArmMotorPower(0);

		setGoliathMotorPower(50);
		mini4BarRetract(WAIT_NONE, ON_STALL_EXIT);

		startTMoGoLift(STATE_EXTENSION_EXTENDED, ON_STALL_EXIT);
		startTDrivePID(750, MODE_FAST, ON_STALL_EXIT);
		waitForTDrive();
		waitForTMoGoLift();

		startTDrivePID(500, MODE_FAST, ON_STALL_EXIT);
		waitForTDrive();

		actionTimed(A_DRIVE, 200, 127);

		startTMoGoLift(STATE_EXTENSION_RETRACTED, ON_STALL_EXIT);
		if (autonomousSide == SIDE_LEFT) startTGyroPID(2, MODE_MOGO, ON_STALL_EXIT);
		else if (autonomousSide == SIDE_RIGHT) startTGyroPID(-2, MODE_MOGO, ON_STALL_EXIT);
		waitForTGyroPID();
		waitForTMoGoLift();

		if ( (*selectedProgram).id == menuItemAuton14P.id || (*selectedProgram).id == menuItemAuton24P.id || (*selectedProgram).id == menuItemAuton9P.id)
		{
			setArmMotorPower(-40);
			setGoliathMotorPower(-50);
			wait1Msec(500);
			setArmMotorPower(0);
			setGoliathMotorPower(50);

			startTDrivePID(100, MODE_ACCURATE, ON_STALL_EXIT);
			waitForTDrive();

			startTMini4Bar(MINI_4_BAR_POTENTIOMETER_EXTENDED_VALUE, WAIT_NONE, ON_STALL_EXIT);
			wait1Msec(400);
			actionTimed(A_ARM, 1000, -40);

			startTMini4Bar(MINI_4_BAR_POTENTIOMETER_RETRACTED_VALUE, WAIT_NONE, ON_STALL_EXIT);

		}

		if ( (*selectedProgram).id == menuItemAuton22P.id)
		{
			startTDrivePID(-1420, MODE_ACCURATE, ON_STALL_EXIT);
			waitForTDrive();
		}
		else if ( (*selectedProgram).id == menuItemAuton24P.id)
		{
			startTDrivePID(-1520, MODE_ACCURATE, ON_STALL_EXIT);
			waitForTDrive();
		}

		if ( (*selectedProgram).id == menuItemAuton22P.id || (*selectedProgram).id == menuItemAuton24P.id )
		{
			setGoliathMotorPower(-50);
			if (autonomousSide == SIDE_LEFT) startTGyroPID(-142, MODE_MOGO, ON_STALL_EXIT);
			else if (autonomousSide == SIDE_RIGHT) startTGyroPID(142, MODE_MOGO, ON_STALL_EXIT);
			wait1Msec(500);
			setGoliathMotorPower(0);
			waitForTGyroPID();

			startTDrivePID(500, MODE_ACCURATE, ON_STALL_EXIT);
			waitForTDrive();

			if (autonomousSide == SIDE_LEFT) startTGyroPID(-243, MODE_MOGO, ON_STALL_EXIT);
			else if (autonomousSide == SIDE_RIGHT) startTGyroPID(243, MODE_MOGO, ON_STALL_EXIT);
			waitForTGyroPID();

			actionTimed(A_DRIVE, 500, 127);
			startTMoGoLift(STATE_EXTENSION_HALFWAY, ON_STALL_EXIT);
			actionTimed(A_DRIVE, 700, 127);

			actionTimed(A_DRIVE, 1200, 127);
			setDriveMotorPower(0);

			setDriveMotorPower(-127);
			wait1Msec(300);

			startTDrivePID(-373, MODE_ACCURATE, ON_STALL_EXIT);
		}
		else if ( (*selectedProgram).id == menuItemAuton12P.id || (*selectedProgram).id == menuItemAuton14P.id )
		{
			startTDrivePID(-500, MODE_ACCURATE, ON_STALL_EXIT);
			waitForTDrive();

			if (autonomousSide == SIDE_LEFT) startTGyroPID(-191, MODE_MOGO, ON_STALL_EXIT);
			else if (autonomousSide == SIDE_RIGHT) startTGyroPID(191, MODE_MOGO, ON_STALL_EXIT);
			setGoliathMotorPower(-50);
			setArmMotorPower(-40);
			wait1Msec(500);
			setGoliathMotorPower(0);
			setArmMotorPower(0);
			waitForTGyroPID();

			startTDrivePID(1250, MODE_ACCURATE, ON_STALL_EXIT);
			startTMoGoLift(STATE_EXTENSION_HALFWAY, ON_STALL_EXIT);
			waitForTMoGoLift();
			waitForTDrive();

			actionTimed(A_DRIVE, 500, 127);
			startTDrivePID(-300, MODE_ACCURATE, ON_STALL_EXIT);
			waitForTDrive();
		}
		else if ( (*selectedProgram).id == menuItemAuton7P.id || (*selectedProgram).id == menuItemAuton9P.id )
		{
			if ( (*selectedProgram).id == menuItemAuton7P.id) startTDrivePID(-500, MODE_ACCURATE, ON_STALL_EXIT);
			else if ( (*selectedProgram).id == menuItemAuton9P.id) startTDrivePID(-600, MODE_ACCURATE, ON_STALL_EXIT);
			waitForTDrive();

			if (autonomousSide == SIDE_LEFT) startTGyroPID(-200, MODE_MOGO, ON_STALL_EXIT);
			else if (autonomousSide == SIDE_RIGHT) startTGyroPID(200, MODE_MOGO, ON_STALL_EXIT);
			setArmMotorPower(-40);
			setGoliathMotorPower(-50);
			wait1Msec(500);
			setGoliathMotorPower(0);
			setArmMotorPower(0);
			waitForTGyroPID();

			startTDrivePID(480, MODE_ACCURATE, ON_STALL_EXIT);
			startTMoGoLift(STATE_EXTENSION_EXTENDED, ON_STALL_EXIT);
			waitForTMoGoLift();
			waitForTDrive();

			startTDrivePID(-300, MODE_ACCURATE, ON_STALL_EXIT);
			waitForTDrive();
		}
	}
	else if ( (*selectedProgram).id == menuItemAutonNone.id)
	{
		setDriveMotorPower(127);
		wait1Msec(5000);
		setDriveMotorPower(0);
	}
	else if ( (*selectedProgram).id == menuItemAutonR10P.id)
	{

		setGoliathMotorPower(40);
		setArmMotorPower(-40);
		wait1Msec(300);
		setArmMotorPower(0);

		startTMini4Bar(MINI_4_BAR_POTENTIOMETER_RETRACTED_VALUE, WAIT_NONE, ON_STALL_EXIT);

		if (autonomousSide == SIDE_LEFT) gyroSoftOffset = 2000;
		else if (autonomousSide == SIDE_RIGHT) gyroSoftOffset = -2000;

		leftDriveMultiplier = 0.6;
		startTDrivePID(-2000, MODE_ACCURATE, ON_STALL_EXIT);
		waitForTDrive();
		leftDriveMultiplier = 1.0;

		if (autonomousSide == SIDE_LEFT) startTGyroPID(-245, MODE_ACCURATE, ON_STALL_EXIT);
		else if (autonomousSide == SIDE_RIGHT) startTGyroPID(245, MODE_ACCURATE, ON_STALL_EXIT);
		waitForTGyroPID();

		startTDrivePID(200, MODE_ACCURATE, ON_STALL_EXIT);
		waitForTDrive();

		startTDrivePID(-200, MODE_ACCURATE, ON_STALL_EXIT);
		startTMoGoLift(STATE_EXTENSION_EXTENDED, ON_STALL_EXIT);
		waitForTDrive();
		waitForTMoGoLift();

		startTDrivePID(200, MODE_ACCURATE, ON_STALL_EXIT);
		waitForTDrive();

		actionTimed(A_DRIVE, 400, 127);

		startTMoGoLift(STATE_EXTENSION_RETRACTED, ON_STALL_EXIT);
		if (autonomousSide == SIDE_LEFT) startTGyroPID(165, MODE_MOGO, ON_STALL_EXIT);
		else if (autonomousSide == SIDE_RIGHT) startTGyroPID(-165, MODE_MOGO, ON_STALL_EXIT);
		waitForTGyroPID();
		startTMoGoLift(STATE_EXTENSION_HALFWAY, ON_STALL_EXIT);

		startTDrivePID(1400, MODE_ACCURATE, ON_STALL_EXIT);
		waitForTDrive();

		actionTimed(A_DRIVE, 200, 127);

		startTDrivePID(-500, MODE_ACCURATE, ON_STALL_EXIT);

	}
	else if ( (*selectedProgram).id == menuItemProgSkills1.id)
	{
		setGoliathMotorPower(40);
		setArmMotorPower(-40);
		wait1Msec(300);
		setArmMotorPower(0);

		setGoliathMotorPower(50);
		mini4BarRetract(WAIT_NONE, ON_STALL_EXIT);

		startTMoGoLift(STATE_EXTENSION_EXTENDED, ON_STALL_EXIT);
		startTDrivePID(1350, MODE_ACCURATE, ON_STALL_EXIT);
		waitForTDrive();

		startTMoGoLift(STATE_EXTENSION_RETRACTED, ON_STALL_EXIT);
		wait1Msec(400);
		if (autonomousSide == SIDE_LEFT) startTGyroPID(2, MODE_MOGO, ON_STALL_EXIT);
		else if (autonomousSide == SIDE_RIGHT) startTGyroPID(-2, MODE_MOGO, ON_STALL_EXIT);
		waitForTGyroPID();
		waitForTMoGoLift();

		startTDrivePID(-1150, MODE_MOGO, ON_STALL_EXIT);
		waitForTDrive();

		if (autonomousSide == SIDE_LEFT) startTGyroPID(50, MODE_MOGO, ON_STALL_EXIT);
		else if (autonomousSide == SIDE_RIGHT) startTGyroPID(-50, MODE_MOGO, ON_STALL_EXIT);
		setGoliathMotorPower(-50);
		setArmMotorPower(-40);
		wait1Msec(500);
		setGoliathMotorPower(50);
		setArmMotorPower(0);
		waitForTGyroPID();

		startTDrivePID(-900, MODE_MOGO, ON_STALL_EXIT);
		waitForTDrive();

		if (autonomousSide == SIDE_LEFT) startTGyroPID(140, MODE_MOGO, ON_STALL_EXIT);
		else if (autonomousSide == SIDE_RIGHT) startTGyroPID(-140, MODE_MOGO, ON_STALL_EXIT);
		waitForTGyroPID();

		actionTimed(A_DRIVE, 500, 127);
		startTMoGoLift(STATE_EXTENSION_HALFWAY, ON_STALL_EXIT);
		actionTimed(A_DRIVE, 700, 127);

		resetGyro(2250);
		wait1Msec(200);

		startTDrivePID(-500, MODE_ACCURATE, ON_STALL_EXIT);
		waitForTDrive();

		if (autonomousSide == SIDE_LEFT) startTGyroPID(-135, MODE_ACCURATE, ON_STALL_EXIT);
		else if (autonomousSide == SIDE_RIGHT) startTGyroPID(135, MODE_ACCURATE, ON_STALL_EXIT);
		waitForTGyroPID();

		startTMoGoLift(STATE_EXTENSION_RETRACTED, ON_STALL_EXIT);
		startTDrivePID(-470, MODE_ACCURATE, ON_STALL_EXIT);
		waitForTDrive();

		startTMoGoLift(STATE_EXTENSION_EXTENDED, ON_STALL_EXIT);
		if (autonomousSide == SIDE_LEFT) startTGyroPID(-28, MODE_ACCURATE, ON_STALL_EXIT);
		else if (autonomousSide == SIDE_RIGHT) startTGyroPID(28, MODE_ACCURATE, ON_STALL_EXIT);
		waitForTGyroPID();

		//go for second mogo
		startTDrivePID(800, MODE_ACCURATE, ON_STALL_EXIT);
		waitForTDrive();

		startTMoGoLift(STATE_EXTENSION_RETRACTED, ON_STALL_EXIT);
		wait1Msec(900);
		if (autonomousSide == SIDE_LEFT) startTGyroPID(-225, MODE_MOGO, ON_STALL_EXIT);
		else if (autonomousSide == SIDE_RIGHT) startTGyroPID(225, MODE_MOGO, ON_STALL_EXIT);
		waitForTGyroPID();

		//drop off second mogo
		startTDrivePID(980, MODE_ACCURATE, ON_STALL_EXIT);
		wait1Msec(200);
		startTMoGoLift(STATE_EXTENSION_HALFWAY, ON_STALL_EXIT);
		waitForTDrive();

		if (autonomousSide == SIDE_LEFT) startTGyroPID(-130, MODE_ACCURATE, ON_STALL_EXIT);
		else if (autonomousSide == SIDE_RIGHT) startTGyroPID(130, MODE_ACCURATE, ON_STALL_EXIT);
		startTMoGoLift(STATE_EXTENSION_RETRACTED, ON_STALL_EXIT);
		waitForTGyroPID();

		startTDrivePID(1100, MODE_ACCURATE, ON_STALL_EXIT);
		waitForTDrive();

		if (autonomousSide == SIDE_LEFT) startTGyroPID(-50, MODE_ACCURATE, ON_STALL_EXIT);
		else if (autonomousSide == SIDE_RIGHT) startTGyroPID(50, MODE_ACCURATE, ON_STALL_EXIT);
		startTMoGoLift(STATE_EXTENSION_EXTENDED, ON_STALL_EXIT);
		waitForTGyroPID();

		actionTimed(A_DRIVE, 300, -127);
		actionTimed(A_DRIVE, 400, -60);
		resetGyro(500);
		wait1Msec(200);

		startTDrivePID(1000, MODE_ACCURATE, ON_STALL_EXIT);
		waitForTDrive();

		//grab third mogo
		startTMoGoLift(STATE_EXTENSION_RETRACTED, ON_STALL_EXIT);
		waitForTMoGoLift();

		startTDrivePID(-300, MODE_MOGO, ON_STALL_EXIT);
		waitForTDrive();

		if (autonomousSide == SIDE_LEFT) startTGyroPID(-245, MODE_MOGO, ON_STALL_EXIT);
		else if (autonomousSide == SIDE_RIGHT) startTGyroPID(245, MODE_MOGO, ON_STALL_EXIT);
		waitForTGyroPID();

		//drop off third mogo
		startTDrivePID(330, MODE_ACCURATE, ON_STALL_EXIT);
		startTMoGoLift(STATE_EXTENSION_HALFWAY, ON_STALL_EXIT);
		waitForTDrive();

		startTDrivePID(-400, MODE_ACCURATE, ON_STALL_EXIT);
		wait1Msec(200);
		startTMoGoLift(STATE_EXTENSION_RETRACTED, ON_STALL_EXIT);
		waitForTDrive();

		if (autonomousSide == SIDE_LEFT) startTGyroPID(-50, MODE_ACCURATE, ON_STALL_EXIT);
		else if (autonomousSide == SIDE_RIGHT) startTGyroPID(50, MODE_ACCURATE, ON_STALL_EXIT);
		waitForTGyroPID();

		startTMoGoLift(STATE_EXTENSION_EXTENDED, ON_STALL_EXIT);
		waitForTMoGoLift();

		startTDrivePID(1250, MODE_ACCURATE, ON_STALL_EXIT);
		waitForTDrive();

		//pick up fourth mogo
		actionTimed(A_DRIVE, 200, 127);
		setDriveMotorPower(0);

		startTMoGoLift(STATE_EXTENSION_HALFWAY, ON_STALL_EXIT);
		startTDrivePID(1380, MODE_ACCURATE, ON_STALL_EXIT);
		waitForTDrive();

		//drop off fourth mogo

		startTDrivePID(-200, MODE_ACCURATE, ON_STALL_EXIT);
		waitForTDrive();

		if (autonomousSide == SIDE_LEFT) startTGyroPID(45, MODE_ACCURATE, ON_STALL_EXIT);
		else if (autonomousSide == SIDE_RIGHT) startTGyroPID(-45, MODE_ACCURATE, ON_STALL_EXIT);
		waitForTGyroPID();

		startTDrivePID(880, MODE_ACCURATE, ON_STALL_EXIT);
		startTMoGoLift(STATE_EXTENSION_EXTENDED, ON_STALL_EXIT);
		waitForTDrive();

		if (autonomousSide == SIDE_LEFT) startTGyroPID(145, MODE_ACCURATE, ON_STALL_EXIT);
		else if (autonomousSide == SIDE_RIGHT) startTGyroPID(-145, MODE_ACCURATE, ON_STALL_EXIT);
		waitForTGyroPID();

		startTDrivePID(640, MODE_ACCURATE, ON_STALL_EXIT);
		waitForTDrive();

		//pick up fifth mogo

		startTMoGoLift(STATE_EXTENSION_RETRACTED, ON_STALL_EXIT);
		waitForTMoGoLift();

		startTDrivePID(-780, MODE_MOGO, ON_STALL_EXIT);
		waitForTDrive();

		if (autonomousSide == SIDE_LEFT) startTGyroPID(45, MODE_MOGO, ON_STALL_EXIT);
		else if (autonomousSide == SIDE_RIGHT) startTGyroPID(-45, MODE_MOGO, ON_STALL_EXIT);
		waitForTGyroPID();

		startTDrivePID(-500, MODE_MOGO, ON_STALL_EXIT);
		waitForTDrive();

		if (autonomousSide == SIDE_LEFT) startTGyroPID(-45, MODE_MOGO, ON_STALL_EXIT);
		else if (autonomousSide == SIDE_RIGHT) startTGyroPID(45, MODE_MOGO, ON_STALL_EXIT);
		waitForTGyroPID();

		//drop off fifth mogo
		startTMoGoLift(STATE_EXTENSION_HALFWAY, ON_STALL_EXIT);
		actionTimed(A_DRIVE, 1500, 127);

		resetGyro(500);
		wait1Msec(200);

		startTDrivePID(-500, MODE_ACCURATE, ON_STALL_EXIT);
		waitForTDrive();

		startTMoGoLift(STATE_EXTENSION_RETRACTED, ON_STALL_EXIT);
		if (autonomousSide == SIDE_LEFT) startTGyroPID(50, MODE_ACCURATE, ON_STALL_EXIT);
		else if (autonomousSide == SIDE_RIGHT) startTGyroPID(-50, MODE_ACCURATE, ON_STALL_EXIT);
		waitForTGyroPID();

		startTDrivePID(680, MODE_ACCURATE, ON_STALL_EXIT);
		waitForTDrive();

		if (autonomousSide == SIDE_LEFT) startTGyroPID(90, MODE_ACCURATE, ON_STALL_EXIT);
		else if (autonomousSide == SIDE_RIGHT) startTGyroPID(-90, MODE_ACCURATE, ON_STALL_EXIT);
		waitForTGyroPID();

		startTMoGoLift(STATE_EXTENSION_EXTENDED, ON_STALL_EXIT);
		startTDrivePID(1200, MODE_ACCURATE, ON_STALL_EXIT);
		waitForTDrive();

		startTMoGoLift(STATE_EXTENSION_RETRACTED, ON_STALL_EXIT);
		if (autonomousSide == SIDE_LEFT) startTGyroPID(88, MODE_MOGO, ON_STALL_EXIT);
		else if (autonomousSide == SIDE_RIGHT) startTGyroPID(-88, MODE_MOGO, ON_STALL_EXIT);
		waitForTGyroPID();
		waitForTMoGoLift();

		startTDrivePID(-1200, MODE_MOGO, ON_STALL_EXIT);
		waitForTDrive();

		if (autonomousSide == SIDE_LEFT) startTGyroPID(-90, MODE_MOGO, ON_STALL_EXIT);
		else if (autonomousSide == SIDE_RIGHT) startTGyroPID(90, MODE_MOGO, ON_STALL_EXIT);
		startTMoGoLift(STATE_EXTENSION_HALFWAY, ON_STALL_EXIT);
		waitForTGyroPID();

		actionTimed(A_DRIVE, 500, 127);

		actionTimed(A_DRIVE, 1000, -127);
	}
}


















/*---------------------------------------------------------------------------*/
/*							PID Mode Task									 */
/*---------------------------------------------------------------------------*/

void userArmPIDControl(short goalPoint, WaitForAction stopWhenMet);

short goalPoint;
void PIDMode()
{
	if ( (*selectedProgram).id == menuItemPIDDrive.id)
	{
		goalPoint = 0;
		while (true)
		{
			clearTimer(T4);
			clearDebugStream();
			SensorValue[encoderDriveLeft] = 0;
			goalPoint = (1 + random(15)) * 100;
			displayLCDCenteredString(1, ConvertIntegerToString(goalPoint));
			SensorValue[LED] = 1;
			drivePIDControl(goalPoint, MODE_ACCURATE, ON_STALL_NOTHING);
			SensorValue[LED] = 0;
			writeDebugStreamLine(ConvertIntegerToString(time1[T4]));
			wait1Msec(5000);

			clearTimer(T4);
			SensorValue[LED] = 1;
			drivePIDControl(-goalPoint, MODE_ACCURATE, ON_STALL_NOTHING);
			SensorValue[LED] = 0;
			writeDebugStreamLine(ConvertIntegerToString(time1[T4]));
			wait1Msec(5000);

/*			clearTimer(T4);
			SensorValue[LED] = 1;
			drivePIDControl(goalPoint, MODE_ACCURATE);
			SensorValue[LED] = 0;
			writeDebugStreamLine(ConvertIntegerToString(time1[T4]));
			wait1Msec(5000);

			clearTimer(T4);
			SensorValue[LED] = 1;
			drivePIDControl(-goalPoint, MODE_ACCURATE);
			SensorValue[LED] = 0;
			writeDebugStreamLine(ConvertIntegerToString(time1[T4]));
			wait1Msec(5000);*/
		}
	}
	else if ( (*selectedProgram).id == menuItemPIDGyro.id)
	{
		while (true)
		{
			goalPoint = (-35 + random(70)) * 10;
			displayLCDCenteredString(0, ConvertIntegerToString(goalPoint));
			SensorValue[LED] = 1;
			gyroPIDControl(goalPoint, MODE_ACCURATE, ON_STALL_NOTHING);
			SensorValue[LED] = 0;
			wait1Msec(1500);
		}
	}
	else if ( (*selectedProgram).id == menuItemPIDArm.id)
	{
		while (true)
		{
			SensorValue[LED] = 1;
			armPIDControl(ARM_POTENTIOMETER_MIN_VALUE + random(ARM_POTENTIOMETER_MAX_VALUE), WAIT, ON_STALL_NOTHING);
			SensorValue[LED] = 0;
			wait1Msec(1000);

			SensorValue[LED] = 1;
			armPIDControl(ARM_POTENTIOMETER_MIN_VALUE + random(ARM_POTENTIOMETER_MAX_VALUE), WAIT, ON_STALL_NOTHING);
			SensorValue[LED] = 0;
			wait1Msec(1000);

			while (getArmSensorValue() > ARM_POTENTIOMETER_MIN_VALUE) { setArmMotorPower(-60); }
			wait1Msec(1000);
		}
	}
	else if ( (*selectedProgram).id == menuItemPIDMini4Bar.id)
	{
		while (true)
		{
			SensorValue[LED] = 1;
			mini4BarExtend(WAIT, ON_STALL_NOTHING);
			waitForTMini4Bar();
			SensorValue[LED] = 0;
			wait1Msec(1000);

			SensorValue[LED] = 1;
			mini4BarRetract(WAIT, ON_STALL_NOTHING);
			waitForTMini4Bar();
			SensorValue[LED] = 0;
			wait1Msec(1000);
		}
	}
	else if ( (*selectedProgram).id == menuItemPIDMoGoLift.id)
	{
		while (true)
		{
			SensorValue[LED] = 1;
			moGoExtend(ON_STALL_NOTHING);
			SensorValue[LED] = 0;
			wait1Msec(1000);

			SensorValue[LED] = 1;
			moGoRetract(ON_STALL_NOTHING);
			SensorValue[LED] = 0;
			wait1Msec(1000);

			SensorValue[LED] = 1;
			moGoHalfway(ON_STALL_NOTHING);
			SensorValue[LED] = 0;
			wait1Msec(1000);

			SensorValue[LED] = 1;
			moGoRetract(ON_STALL_NOTHING);
			SensorValue[LED] = 0;
			wait1Msec(1000);

			SensorValue[LED] = 1;
			moGoExtend(ON_STALL_NOTHING);
			SensorValue[LED] = 0;
			wait1Msec(1000);

			SensorValue[LED] = 1;
			moGoHalfway(ON_STALL_NOTHING);
			SensorValue[LED] = 0;
			wait1Msec(1000);
		}
	}
	else if ( (*selectedProgram).id == menuItemPIDCustom.id)
	{
		while (true)
		{
			SensorValue[LED] = 1;
			userArmPIDControl(( (ARM_POTENTIOMETER_MIN_VALUE + 200) / 100 + random( (ARM_POTENTIOMETER_MAX_VALUE - ARM_POTENTIOMETER_MIN_VALUE - 200) / 100) ) * 100, WAIT);
			SensorValue[LED] = 0;
			wait1Msec(1000);

			SensorValue[LED] = 1;
			userArmPIDControl(( (ARM_POTENTIOMETER_MIN_VALUE + 200) / 100 + random( (ARM_POTENTIOMETER_MAX_VALUE - ARM_POTENTIOMETER_MIN_VALUE - 200) / 100) ) * 100, WAIT);
			SensorValue[LED] = 0;
			wait1Msec(1000);

			while (getArmSensorValue() > ARM_POTENTIOMETER_MIN_VALUE + 100) { setArmMotorPower(-60); }
			setArmMotorPower(0);
			wait1Msec(1000);
		}
	}
}



























int sensorToMotorPortMap[] = {
	/* Port 1 */			potentiometerMini4Bar,
	/* Port 2 */			potentiometerArm,
	/* Port 3 */			potentiometerArm,
	/* Port 4 */			potentiometerMoGoLift,
	/* Port 5 */			potentiometerMoGoLift,
	/* Port 6 */			encoderDriveLeft,
	/* Port 7 */			encoderDriveLeft,
	/* Port 8 */			encoderDriveRight,
	/* Port 9 */			encoderDriveRight,
	/* Port 10 */			sensorNone
};

//direction each motor should go when applied positive power (1 = positive, -1 = negative)
int directions[] = {
	/* Port 1 */			-1,
	/* Port 2 */			-1,
	/* Port 3 */			-1,
	/* Port 4 */			-1,
	/* Port 5 */			-1,
	/* Port 6 */			-1,
	/* Port 7 */			-1,
	/* Port 8 */			-1,
	/* Port 9 */			-1,
	/* Port 10 */			-1,
};


int motorPorts[] = { port1, port2, port3, port4, port5, port6, port7, port8, port9, port10 };
ubyte motorPointer;
short lastSensorValue;
task MiscellaneousTask();

void nextMotor()
{
	if (motorPointer < 10) motorPointer++;
	else motorPointer = 0;
}

void previousMotor()
{
	if (motorPointer > 0) motorPointer--;
	else motorPointer = 10;
}


void MotorManualCheck()
{
	stopTask(loadLCDScreen);

	displayLCDCenteredString(0, "Manual Check");
	string sMotorNum = "";
	string LCDLine = "";
	while (true)
	{
		if (motorPointer == 10)
		{
			displayLCDCenteredString(0, "Go Back");
			displayLCDCenteredString(1, "<    Select    >");
		}
		else
		{
			sprintf(sMotorNum, "%2.0f%c", motorPointer + 1);
			LCDLine = "Port";
			LCDLine += sMotorNum;
			LCDLine += ": ";
		}

		if (!isJoystickLCDMode())
		{
			if (motorPointer == 10)
			{
				waitForLCDButtonRelease();
				waitForLCDButtonPress();

				if (vexRT[BTN_JOY_LCD_NEXT] == 1)
				{
					while (vexRT[BTN_JOY_LCD_NEXT] == 1) { }
					nextMotor();
				}
				else if (vexRT[BTN_JOY_LCD_PREVIOUS] == 1)
				{
					while (vexRT[BTN_JOY_LCD_PREVIOUS] == 1) { }
					previousMotor();
				}
				else if (vexRT[BTN_JOY_LCD_SELECT] == 1 || nLCDButtons == LCDCenterButton) {
					startTask(loadLCDScreen);
					stopTask(MiscellaneousTask);
				}
			}
			else
			{
				if (motor[motorPorts[motorPointer]] == 127) LCDLine += "127";
				else if (motor[motorPorts[motorPointer]] == -127) LCDLine += "-127";
				else if (motor[motorPorts[motorPointer]] == 0) LCDLine += "0";

				displayLCDCenteredString(1, LCDLine);


				if (vexRT[BTN_JOY_LCD_NEXT] == 1)
				{
					while (vexRT[BTN_JOY_LCD_NEXT] == 1) { }
					nextMotor();
				}
				else if (vexRT[BTN_JOY_LCD_PREVIOUS] == 1)
				{
					while (vexRT[BTN_JOY_LCD_PREVIOUS] == 1) { }
					previousMotor();
				}
				else if (vexRT[BTN_POSITIVE_POWER] == 1) motor[motorPorts[motorPointer]] = 127;
				else if (vexRT[BTN_NEGATIVE_POWER] == 1) motor[motorPorts[motorPointer]] = -127;
				else if (vexRT[BTN_STOP_MOTOR] == 1) motor[motorPorts[motorPointer]] = 0;
				else if (vexRT[BTN_STOP_ALL_MOTORS] == 1) allMotorsOff();
			}
		}
	}
}

void MotorSelfCheck()
{
	stopTask(loadLCDScreen);

	int passTable[10];
	bool hasTestPassed = true;
	string sMotorNum;
	displayLCDCenteredString(0, "Starting Test...");
	clearLCDLine(1);
	wait1Msec(2000);

	string LCDLine = "";

	for (int i = 0; i < 10; i++)
	{
		sMotorNum = "";
		sprintf(sMotorNum, "%2.0f%c", i + 1);
		LCDLine = "Testing Port ";
		LCDLine += sMotorNum;
		displayLCDCenteredString(0, LCDLine);
		displayLCDCenteredString(1, "Start?");

		waitForLCDButtonRelease();

		while (nLCDButtons != LCDCenterButton && vexRT[BTN_JOY_LCD_SELECT] == 0) { }
		displayLCDCenteredString(1, "Please Wait...");

		bool hasPassed = false;
		lastSensorValue = SensorValue[sensorToMotorPortMap[i]];

		motor[i] = MOTOR_TEST_POWER;
		wait1Msec(10);
		clearTimer(T1);

		short newSensorValue;
		ubyte errorBounds;

		if (SensorType[sensorToMotorPortMap[i]] == sensorPotentiometer) errorBounds = ERROR_BOUNDS_POTENTIOMETER;
		else if (SensorType[sensorToMotorPortMap[i]] == sensorQuadEncoder) errorBounds = ERROR_BOUNDS_ENCODER;

		while (time1[T1] < MOTOR_TEST_DURATION)
		{
			newSensorValue = SensorValue[sensorToMotorPortMap[i]];
			if (newSensorValue - lastSensorValue != 0)
			{
				if (abs(newSensorValue - lastSensorValue) > errorBounds)
				{
					if ( (newSensorValue - lastSensorValue / abs(newSensorValue - lastSensorValue)) == directions[i])
					{
						hasPassed = true;
						break;
					}
					else if ( (newSensorValue - lastSensorValue / abs(newSensorValue - lastSensorValue)) * (-1) == directions[i] && time1[T1] > 500 )
					{
						hasPassed = false;
						break;
					}
				}
			}
		}

		int direction = 0;
		if (abs(newSensorValue - lastSensorValue) > errorBounds) direction = (newSensorValue - lastSensorValue / abs(newSensorValue - lastSensorValue));
		if (direction == directions[i]) passTable[i] = 1;
		else if (direction * (-1) == directions[i]) passTable = -1;
		else if (direction == 0) passTable[i] = 0;

		motor[i] = 0;

		if (!hasPassed)
		{
			LCDLine = "Port ";
			LCDLine += sMotorNum;
			LCDLine += " Failed";
			displayLCDCenteredString(0, LCDLine);

			if (passTable[i] == -1) displayLCDCenteredString(1, "Cause: Inversion");
			else if (passTable[i] == 0) displayLCDCenteredString(1, "Cause: Idle");
			hasTestPassed = false;
			wait1Msec(2000);

			displayLCDCenteredString(0, "Continuing In");
			displayLCDCenteredString(1, "Retry?");
			clearTimer(T1);
			while (time1[T1] < 3000)
			{
				LCDLine = "";
				sprintf(LCDLine, "%1.0f%c", (3 - (time1[T1] / 1000) ));
				displayLCDString(0, 15, LCDLine);

				if (nLCDButtons == LCDCenterButton || vexRT[BTN_JOY_LCD_SELECT] == 1)
				{
					i--;
					break;
				}
			}
		}
		else
		{
			LCDLine = "Port ";
			LCDLine += sMotorNum;
			displayLCDCenteredString(0, LCDLine);
			displayLCDCenteredString(1, "Is Functional");
			wait1Msec(2000);
		}
	}

	displayLCDCenteredString(0, "Summary");
	wait1Msec(2000);
	for (int i = 0; i < 10; i++)
	{
		sMotorNum = "";
		sprintf(sMotorNum, "%2.0f%c", i + 1);
		LCDLine = "Port ";
		LCDLine += sMotorNum;
		if (passTable[i] != 1) LCDLine += " Failed";
		displayLCDCenteredString(0, LCDLine);

		if (passTable[i] == -1) displayLCDCenteredString(1, "Cause: Inversion");
		else if (passTable[i] == 0) displayLCDCenteredString(1, "Cause: Idle");
		else displayLCDCenteredString(1, "Is Functional");
		wait1Msec(2000);
	}


	startTask(loadLCDScreen);
	stopTask(MiscellaneousTask);
}


task MiscellaneousTask()
{
	if ( (*selectedProgram).id == menuItemMotorCheckAuto.id) MotorSelfCheck();
	else if ( (*selectedProgram).id == menuItemMotorCheckManual.id) MotorManualCheck();
	else if ((*selectedProgram).idx < MENU_LIST_PID_LENGTH - 1 && (*menuListPID[ (*selectedProgram).idx ]).id == (*selectedProgram).id) PIDMode();
}
















































/*---------------------------------------------------------------------------*/
/*							User Control Task								 */
/*---------------------------------------------------------------------------*/




bool lockControls = IS_CONTROL_LOCK_ENABLED;
bool isAutonRecorderEnabled = false;
bool areSensorsOverridden = false;
bool isArmReadyMacroActive = false;
bool isMoGoStackConeMacroActive = false;
bool isToggleActive = true;
StateExtension stateMoGoLiftCurrent = STATE_EXTENSION_RETRACTED;
StateExtension stateMini4BarCurrent = STATE_EXTENSION_RETRACTED;




task Arm()
{

	float pGain = (2.0/10.0);
	float iGain = (1.0/10000.0);
	float dGain = (0.0/10.0);

	while (true)
	{
		if (!lockControls && !isJoystickLCDMode())
		{
			/* Allow joystick control of arm if less than upper limit of sensors are overriden */
			if (!isMoGoStackConeMacroActive && !isArmReadyMacroActive && (areSensorsOverridden || abs(vexRT[JOY_ARM]) > ARM_JOYSTICK_DEADZONE))
			{
				while (!isMoGoStackConeMacroActive && !isArmReadyMacroActive && (areSensorsOverridden || abs(vexRT[JOY_ARM]) > ARM_JOYSTICK_DEADZONE))
				{
					setArmMotorPower(vexRT[JOY_ARM]);
				}
				setArmMotorPower(0);

				/* while (abs(vexRT[JOY_ARM]) < ARM_JOYSTICK_DEADZONE && vexRT[BTN_ARM_HIGH_GOAL_PID] == 0 && getArmSensorValue() > correctGoalPoint(ARM_POTENTIOMETER_CONE_HEIGHT_VALUE + 200, ARM_POTENTIOMETER_MULTIPLIER) )
				{
				setArmMotorPower(20);
				}*/
			}
			/* If PID button is pressed, bring arm to carry value */
			else if (vexRT[BTN_ARM_HIGH_GOAL_PID] == 1)
			{
				while (vexRT[BTN_ARM_HIGH_GOAL_PID] == 1) { }
				int errorSum = 0;
				short goalPoint = correctArmGoalPoint(ARM_POTENTIOMETER_HIGH_GOAL_VALUE);
				byte error = goalPoint - getArmSensorValue();
				byte errorDifference = 0;
				int lastMotorPower = 0;
				int newPower = 0;

				/* Stay in PID mode until user uses joystick */
				while (abs(vexRT[JOY_ARM]) < ARM_JOYSTICK_DEADZONE && vexRT[BTN_ARM_HIGH_GOAL_PID] == 0)
				{
					errorDifference = error - (goalPoint - getArmSensorValue());
					error = goalPoint - getArmSensorValue();
					errorSum = errorSum + error;
					lastMotorPower = newPower;

					/* Prevent wind-up. Set max integral gain to full power. */
					if (errorSum * iGain > 127) errorSum = 127.0 / iGain;
					else if (errorSum * iGain < -127) errorSum = -127.0 / iGain;

					newPower = error * pGain + errorSum * iGain - dGain * errorDifference;
					setArmMotorPower(newPower);
					wait1Msec(50);
				}
			}
		}
	}
}



task Drive()
{


	short axisX, axisY;

	while (true)
	{
		if (!isAutonRecorderEnabled)
		{
			if (!lockControls && !isJoystickLCDMode())
			{
				/* Drive if joystick is greater than deadzone */
				if (abs(vexRT[JOY_DRIVE_X]) > DRIVE_JOYSTICK_DEADZONE || abs(vexRT[JOY_DRIVE_Y]) > DRIVE_JOYSTICK_DEADZONE)
				{
					axisY = 0.0000635768 * pow(vexRT[Ch2], 3) - 0.0254307 * vexRT[Ch2];
					axisX = 0.00006 * pow(vexRT[Ch1], 3) - 0.0254307 * vexRT[Ch1];

					setDriveMotorPower( SlewRate(getDriveLeftMotorPower(), axisY + axisX, 0.15, 20), SlewRate(getDriveRightMotorPower(), axisY - axisX, 0.15, 20) );
				}
				else setDriveMotorPower( SlewRate(getDriveLeftMotorPower(), 0, 0.15, 20), SlewRate(getDriveRightMotorPower(), 0, 0.15, 20) );
			}
			wait1Msec(25);
		}
		else if (isAutonRecorderEnabled)
		{
			if (vexRT[Ch2] > 50) setDriveMotorPower(70);
			else if (vexRT[Ch2] < -50) setDriveMotorPower(-70);
			else if (vexRT[Ch1] > 50) setDriveMotorPower(70, -70);
			else if (vexRT[Ch1] < -50) setDriveMotorPower(-70, 70);
			else setDriveMotorPower(0);
		}
	}
}

#define FLAG_BIT_BTN6U	1
#define FLAG_BIT_BTN6D	2
#define FLAG_BIT_BTN5U	4
#define FLAG_BIT_BTN5D	8
#define FLAG_BIT_BTN7D	16
#define FLAG_BIT_BTN7L	32
#define FLAG_BIT_BTN7U	64
#define FLAG_BIT_BTN7R	128
#define FLAG_BIT_BTN8D	256
#define FLAG_BIT_BTN8L	512
#define FLAG_BIT_BTN8U	1024
#define FLAG_BIT_BTN8R	2048

#define FLAG_BIT_CH1	5096
#define FLAG_BIT_CH2	10192
#define FLAG_BIT_CH3	20384
#define FLAG_BIT_CH4	40768

short getControllerStateFlag()
{
	short flag = 0;

	flag += (vexRT[Btn6U] == 1) ? FLAG_BIT_BTN6U : 0;
	flag += (vexRT[Btn6D] == 1) ? FLAG_BIT_BTN6D : 0;
	flag += (vexRT[Btn5U] == 1) ? FLAG_BIT_BTN5U : 0;
	flag += (vexRT[Btn5D] == 1) ? FLAG_BIT_BTN5D : 0;
	flag += (vexRT[Btn7D] == 1) ? FLAG_BIT_BTN7D : 0;
	flag += (vexRT[Btn7L] == 1) ? FLAG_BIT_BTN7L : 0;
	flag += (vexRT[Btn7U] == 1) ? FLAG_BIT_BTN7U : 0;
	flag += (vexRT[Btn7R] == 1) ? FLAG_BIT_BTN7R : 0;
	flag += (vexRT[Btn8D] == 1) ? FLAG_BIT_BTN8D : 0;
	flag += (vexRT[Btn8L] == 1) ? FLAG_BIT_BTN8L : 0;
	flag += (vexRT[Btn8U] == 1) ? FLAG_BIT_BTN8U : 0;
	flag += (vexRT[Btn8R] == 1) ? FLAG_BIT_BTN8R : 0;

	flag += (abs(vexRT[Ch1]) > 20) ? FLAG_BIT_CH1 : 0;
	flag += (abs(vexRT[Ch2]) > 20) ? FLAG_BIT_CH2 : 0;
	flag += (abs(vexRT[Ch3]) > 20) ? FLAG_BIT_CH3 : 0;
	flag += (abs(vexRT[Ch4]) > 20) ? FLAG_BIT_CH4 : 0;

	return flag;
}

bool isControllerStateButtonPressed(short oldFlag, short buttonFlags)
{
	return (((oldFlag | getControllerStateFlag()) - oldFlag) & buttonFlags) > 0;
}

short ConvertButtonToFlagBit(int btn)
{
	switch (btn)
	{
		case Btn6U:
			return FLAG_BIT_BTN6U;

		case Btn6D:
			return FLAG_BIT_BTN6D;

		case Btn5U:
			return FLAG_BIT_BTN5U;

		case Btn5D:
			return FLAG_BIT_BTN5D;

		case Btn7D:
			return FLAG_BIT_BTN7D;

		case Btn7L:
			return FLAG_BIT_BTN7L;

		case Btn7U:
			return FLAG_BIT_BTN7U;

		case Btn7R:
			return FLAG_BIT_BTN7R;

		case Btn8D:
			return FLAG_BIT_BTN8D;

		case Btn8L:
			return FLAG_BIT_BTN8L;

		case Btn8U:
			return FLAG_BIT_BTN8U;

		case Btn8R:
			return FLAG_BIT_BTN8R;

		case Ch1:
			return FLAG_BIT_CH1;

		case Ch2:
			return FLAG_BIT_CH2;

		case Ch3:
			return FLAG_BIT_CH3;

		case Ch4:
			return FLAG_BIT_CH4;

		default:
			return 0;
	}
}


void userMini4BarPIDControl(short goalPoint, WaitForAction stopWhenMet)
{
	float pGain = 0.2;
	float iGain = 0.0001;
	float dGain = 4;

	goalPoint = correctMini4BarGoalPoint(goalPoint);

	short error = goalPoint - getMini4BarSensorValue();
	int errorSum = 0;
	short errorDifference = 0;

	short oldFlag = getControllerStateFlag();
	ubyte initialButtonState = vexRT[BTN_MINI_4_BAR_HOLD_AUTO];
	short buttonMask = ConvertButtonToFlagBit(BTN_READY_ARM_MACRO) + ConvertButtonToFlagBit(BTN_MOGO_STACK_MACRO) + ConvertButtonToFlagBit(BTN_MINI_4_BAR_HOLD_AUTO) + ConvertButtonToFlagBit(BTN_SENSOR_OVERRIDE) + ConvertButtonToFlagBit(BTN_MINI_4_BAR_TOGGLE_ENABLE);

	while ( (stopWhenMet == WAIT && abs(error) > 30) || (stopWhenMet == WAIT_NONE
		&& ( (initialButtonState == vexRT[BTN_MINI_4_BAR_HOLD_AUTO] && !isToggleActive) || isToggleActive)
	&& !isControllerStateButtonPressed(oldFlag, buttonMask)
	&& ( goalPoint == MINI_4_BAR_POTENTIOMETER_RETRACTED_VALUE || ( getArmSensorValue() < ARM_POTENTIOMETER_CONE_HEIGHT_VALUE
	&& goalPoint != MINI_4_BAR_POTENTIOMETER_PARALLEL_VALUE) || (  getArmSensorValue() >= ARM_POTENTIOMETER_CONE_HEIGHT_VALUE && goalPoint == MINI_4_BAR_POTENTIOMETER_PARALLEL_VALUE ) ) ) )
	{
		oldFlag = getControllerStateFlag();
		errorDifference = error - (goalPoint - getMini4BarSensorValue());
		error = goalPoint - getMini4BarSensorValue();
		errorSum += error;

		if (abs(error) < 30) errorSum = 0;

		setMini4BarMotorPower(error * pGain + errorSum * iGain - errorDifference * dGain);
		wait1Msec(1);
	}
	setMini4BarMotorPower(0);
}


void userArmPIDControl(short goalPoint, WaitForAction stopWhenMet)
{
	float pGain = 0.07;
	float iGain = 0.0002;
	float dGain = 0.1;

	goalPoint = correctArmGoalPoint(goalPoint);

	short error = goalPoint - getArmSensorValue();
	int errorSum = 0;
	short errorDifference = 0;

	short oldFlag = getControllerStateFlag();
	int timeInitial = time1[T1];
	short buttonMask = ConvertButtonToFlagBit(BTN_SENSOR_OVERRIDE) + ConvertButtonToFlagBit(BTN_READY_ARM_MACRO) + ConvertButtonToFlagBit(BTN_MOGO_STACK_MACRO) + ConvertButtonToFlagBit(JOY_ARM);

	while ( (stopWhenMet == WAIT && time1[T1] - timeInitial < 150 || stopWhenMet == WAIT_NONE ) && !isControllerStateButtonPressed(oldFlag, buttonMask) )
	{
		oldFlag = getControllerStateFlag();
		errorDifference = error - (goalPoint - getArmSensorValue());
		error = goalPoint - getArmSensorValue();
		errorSum += error;

		if (error > 0 && error < 30) errorSum = 20.0 / iGain;
		else if (error < 0 && error > -30) errorSum = 0;

		if (errorSum * iGain > 127.0) errorSum = 127.0 / iGain;
		else if (errorSum * iGain < -127.0) errorSum = -127.0 / iGain;

		if (abs(error) > 40) timeInitial = time1[T1];
		setArmMotorPower(error * pGain + errorSum * iGain - errorDifference * dGain);

		wait1Msec(1);
	}
	setArmMotorPower(20);
}



task Goliath()
{
	while (true)
	{
		if (!lockControls && !isJoystickLCDMode() && !isMoGoStackConeMacroActive && !isArmReadyMacroActive)
		{
			if (vexRT[BTN_SENSOR_OVERRIDE] == 1) setGoliathMotorPower(0);
			else if (vexRT[BTN_GOLIATH_REVERSE] == 1)
			{
				setGoliathMotorPower(-50);
				while (vexRT[BTN_GOLIATH_REVERSE] == 1) { }

				setGoliathMotorPower(50);
			}
			else if (!areSensorsOverridden)
			{
				if (getArmMotorPower() <= 0) setGoliathMotorPower(50);
				else if (getArmMotorPower() > 0) setGoliathMotorPower(15);

			}
		}
	}
}


task Mini4Bar()
{
	while (true)
	{
		if (!lockControls && !isJoystickLCDMode())
		{
			if (vexRT[BTN_SENSOR_OVERRIDE] == 1)
			{
				while (vexRT[BTN_SENSOR_OVERRIDE] == 1) { }
				areSensorsOverridden = !areSensorsOverridden;
			}
			/*
			else if (vexRT[BTN_MOGO_STACK_MACRO] == 1)
			{
				isMoGoStackConeMacroActive = true;
				startTMini4Bar(MINI_4_BAR_POTENTIOMETER_EXTENDED_VALUE, WAIT_NONE);
				while (getArmSensorValue() > correctArmGoalPoint(ARM_POTENTIOMETER_CONE_HEIGHT_VALUE + 100)) setArmMotorPower(-60);
				setArmMotorPower(-30);
				setGoliathMotorPower(50);

				wait1Msec(1000);
				stopTask(tMini4Bar);
				startTMini4Bar(MINI_4_BAR_POTENTIOMETER_PARALLEL_VALUE, WAIT_NONE);
				if (numOfInternalCones >= 2) userArmPIDControl(ARM_POTENTIOMETER_CONE_STACK_INITIAL_VALUE + numOfInternalCones * ARM_POTENTIOMETER_CONE_MULTIPLIER + 200, WAIT);
				stopTask(tMini4Bar);
				stateMini4BarCurrent = STATE_EXTENSION_RETRACTED;
				userMini4BarPIDControl(MINI_4_BAR_POTENTIOMETER_RETRACTED_VALUE, WAIT);

				if (numOfInternalCones >= 2) userArmPIDControl(ARM_POTENTIOMETER_CONE_STACK_INITIAL_VALUE + numOfInternalCones * ARM_POTENTIOMETER_CONE_MULTIPLIER + 200, WAIT);

				setGoliathMotorPower(-50);
				wait1Msec(800);
				setGoliathMotorPower(50);
				numOfInternalCones++;
				isMoGoStackConeMacroActive = false;
			}
			else if (vexRT[BTN_READY_ARM_MACRO] == 1)
			{
				while (vexRT[BTN_READY_ARM_MACRO] == 1) { }
				isArmReadyMacroActive = true;
				stateMini4BarCurrent = STATE_EXTENSION_EXTENDED;
				userMini4BarPIDControl(MINI_4_BAR_POTENTIOMETER_PARALLEL_VALUE, WAIT);
				setArmMotorPower(127);
				while (abs(vexRT[JOY_ARM]) < ARM_JOYSTICK_DEADZONE && vexRT[BTN_MOGO_STACK_MACRO] == 0 && vexRT[BTN_ARM_HIGH_GOAL_PID] == 0 &&
					getArmSensorValue() < ( (numOfInternalCones >= 2) ? correctArmGoalPoint(ARM_POTENTIOMETER_CONE_STACK_INITIAL_VALUE + numOfInternalCones * ARM_POTENTIOMETER_CONE_MULTIPLIER + 200) : correctArmGoalPoint(ARM_POTENTIOMETER_MIN_VALUE + 300) ) ) { }
				setArmMotorPower(0);
				stateMini4BarCurrent = STATE_EXTENSION_EXTENDED;
				if (getArmSensorValue() > ARM_POTENTIOMETER_CONE_HEIGHT_VALUE) userMini4BarPIDControl(MINI_4_BAR_POTENTIOMETER_PARALLEL_VALUE, WAIT);
				else userMini4BarPIDControl(MINI_4_BAR_POTENTIOMETER_EXTENDED_VALUE, WAIT);

				while (getArmSensorValue() > correctArmGoalPoint(ARM_POTENTIOMETER_CONE_HEIGHT_VALUE) &&  vexRT[BTN_SENSOR_OVERRIDE] == 0 && vexRT[BTN_MOGO_STACK_MACRO] == 0 && abs(vexRT[JOY_ARM]) < ARM_JOYSTICK_DEADZONE ) setArmMotorPower(-60);
				setArmMotorPower(0);
				isArmReadyMacroActive = false;
			}
*/
			if (!areSensorsOverridden)
			{
				if (!isToggleActive)
				{
					if (vexRT[BTN_MINI_4_BAR_HOLD_AUTO] == 1)
					{
						stateMini4BarCurrent = STATE_EXTENSION_RETRACTED;
						userMini4BarPIDControl(MINI_4_BAR_POTENTIOMETER_RETRACTED_VALUE, WAIT_NONE);
					}
					else
					{
						stateMini4BarCurrent = STATE_EXTENSION_EXTENDED;
						if (getArmSensorValue() > ARM_POTENTIOMETER_CONE_HEIGHT_VALUE) userMini4BarPIDControl(MINI_4_BAR_POTENTIOMETER_PARALLEL_VALUE, WAIT_NONE);
						else userMini4BarPIDControl(MINI_4_BAR_POTENTIOMETER_EXTENDED_VALUE, WAIT_NONE);
					}
				}
				else if (isToggleActive)
				{
					if (vexRT[BTN_MINI_4_BAR_TOGGLE_AUTO] == 1)
					{
						stateMini4BarCurrent = (stateMini4BarCurrent == STATE_EXTENSION_EXTENDED) ? STATE_EXTENSION_RETRACTED : STATE_EXTENSION_EXTENDED;
						while (vexRT[BTN_MINI_4_BAR_TOGGLE_AUTO] == 1) { }
					}
					else if (stateMini4BarCurrent == STATE_EXTENSION_EXTENDED)
					{
						if (getArmSensorValue() > ARM_POTENTIOMETER_CONE_HEIGHT_VALUE) userMini4BarPIDControl(MINI_4_BAR_POTENTIOMETER_PARALLEL_VALUE, WAIT_NONE);
						else userMini4BarPIDControl(MINI_4_BAR_POTENTIOMETER_EXTENDED_VALUE, WAIT_NONE);
					}
					else if (stateMini4BarCurrent == STATE_EXTENSION_RETRACTED)
					{
						userMini4BarPIDControl(MINI_4_BAR_POTENTIOMETER_RETRACTED_VALUE, WAIT_NONE);
					}
				}
			}
			else if (areSensorsOverridden)
			{
				if (vexRT[BTN_MINI_4_BAR_EXTEND_MANUAL] == 1)
				{
					while (vexRT[BTN_MINI_4_BAR_EXTEND_MANUAL] == 1)
						setMini4BarMotorPower(127);
					setMini4BarMotorPower(0);
				}
				else if (vexRT[BTN_MINI_4_BAR_RETRACT_MANUAL] == 1)
				{
					while (vexRT[BTN_MINI_4_BAR_RETRACT_MANUAL] == 1)
						setMini4BarMotorPower(-127);
					setMini4BarMotorPower(0);
				}
			}
		}
	}
}



task MoGoLift()
{
	while (true)
	{
		if (!lockControls && !isJoystickLCDMode())
		{
			if (!areSensorsOverridden)
			{
				if (vexRT[BTN_MINI_4_BAR_TOGGLE_ENABLE] == 1)
				{
					isToggleActive = !isToggleActive;
					while (vexRT[BTN_MINI_4_BAR_TOGGLE_ENABLE] == 1) { }
				}
				if (vexRT[BTN_MOGO_LIFT_HALFWAY_AUTO] == 1)
				{
					stateMoGoLiftCurrent = STATE_EXTENSION_HALFWAY;
					float pGain = 0.08;
					float iGain = 0.0003;
					float dGain = 2.0;

					short error = correctMoGoLiftGoalPoint(MOGO_LIFT_POTENTIOMETER_HALFWAY_VALUE) - getMoGoLiftSensorValue();
					short errorDifference = 0;
					int errorSum = 0;
					int timeInitial = time1[T4];

					while (vexRT[BTN_MOGO_LIFT_TOGGLE_AUTO] == 0 && vexRT[BTN_MOGO_LIFT_EXTEND_MANUAL] == 0 && vexRT[BTN_MOGO_LIFT_RETRACT_MANUAL] == 0 && vexRT[BTN_SENSOR_OVERRIDE] == 0)
					{
						errorDifference = error - (correctMoGoLiftGoalPoint(MOGO_LIFT_POTENTIOMETER_HALFWAY_VALUE) - getMoGoLiftSensorValue());
						error = correctMoGoLiftGoalPoint(MOGO_LIFT_POTENTIOMETER_HALFWAY_VALUE) - getMoGoLiftSensorValue();
						errorSum += error;

						if (abs(error) < 30) errorSum = 0;
						else if (abs(error) >= 30) timeInitial = time1[T4];

						setMoGoLiftMotorPower(error * pGain + errorSum * iGain - errorDifference * dGain);

						wait1Msec(5);
					}
					setMoGoLiftMotorPower(0);
				}
				if (isToggleActive)
				{
					if (vexRT[BTN_MOGO_LIFT_TOGGLE_AUTO] == 1)
					{
						while (vexRT[BTN_MOGO_LIFT_TOGGLE_AUTO] == 1) { }
						stateMoGoLiftCurrent = (stateMoGoLiftCurrent == STATE_EXTENSION_RETRACTED) ? STATE_EXTENSION_EXTENDED : STATE_EXTENSION_RETRACTED;
						numOfInternalCones = 0;
					}

					if (stateMoGoLiftCurrent == STATE_EXTENSION_RETRACTED)
					{
						while (getMoGoLiftSensorValue() > correctMoGoLiftGoalPoint(MOGO_LIFT_POTENTIOMETER_RETRACTED_VALUE + 100) && vexRT[BTN_MOGO_LIFT_TOGGLE_AUTO] != 1)
						{
							setMoGoLiftMotorPower(-127);
						}
						setMoGoLiftMotorPower(0);
					}
					else if (stateMoGoLiftCurrent == STATE_EXTENSION_EXTENDED)
					{
						float dGain = 2.0;

						short error = correctMoGoLiftGoalPoint(MOGO_LIFT_POTENTIOMETER_EXTENDED_VALUE) - getMoGoLiftSensorValue();
						short errorDifference = 0;


						while (getMoGoLiftSensorValue() < correctMoGoLiftGoalPoint(MOGO_LIFT_POTENTIOMETER_EXTENDED_VALUE) - 100 && !areSensorsOverridden && vexRT[BTN_MOGO_LIFT_TOGGLE_AUTO] == 0)
						{
							errorDifference = error - ( correctMoGoLiftGoalPoint(MOGO_LIFT_POTENTIOMETER_EXTENDED_VALUE) - getMoGoLiftSensorValue());
							error = correctMoGoLiftGoalPoint(MOGO_LIFT_POTENTIOMETER_EXTENDED_VALUE) - getMoGoLiftSensorValue();
							setMoGoLiftMotorPower(50 - dGain * abs(errorDifference) );
						}
						setMoGoLiftMotorPower(0);
					}
				}
				else if (!isToggleActive)
				{
					if (vexRT[BTN_MOGO_LIFT_EXTEND_MANUAL] == 1)
					{
						while (vexRT[BTN_MOGO_LIFT_EXTEND_MANUAL] == 1) setMoGoLiftMotorPower(127);
						setMoGoLiftMotorPower(0);
					}
					else if (vexRT[BTN_MOGO_LIFT_RETRACT_MANUAL] == 1)
					{
						while (vexRT[BTN_MOGO_LIFT_RETRACT_MANUAL] == 1) setMoGoLiftMotorPower(-127);
						setMoGoLiftMotorPower(0);
					}
				}
			}
			else if (areSensorsOverridden)
			{
				if (vexRT[BTN_MOGO_LIFT_EXTEND_MANUAL] == 1)
				{
					while (vexRT[BTN_MOGO_LIFT_EXTEND_MANUAL] == 1) setMoGoLiftMotorPower(127);
					setMoGoLiftMotorPower(0);
				}
				else if (vexRT[BTN_MOGO_LIFT_RETRACT_MANUAL] == 1)
				{
					while (vexRT[BTN_MOGO_LIFT_RETRACT_MANUAL] == 1) setMoGoLiftMotorPower(-127);
					setMoGoLiftMotorPower(0);
				}
			}
		}
	}
}




/* Main user control task */
task usercontrol()
{
	numOfInternalCones = 0;


	if (IS_ARM_ENABLED) startTask(Arm);
	if (IS_DRIVE_ENABLED) startTask(Drive);
	if (IS_GOLIATH_ENABLED) startTask(Goliath);
	if (IS_MINI_4_BAR_ENABLED) startTask(Mini4Bar);
	if (IS_MOGO_LIFT_ENABLED) startTask(MoGoLift);

	if (getTaskState(loadLCDScreen) == taskStateStopped) startTask(loadLCDScreen);

	if (isLCDEnabled)
	{
		displayLCDCenteredString(0, "Daud-_-Jaan");
		displayLCDCenteredString(1, "User Control");
	}

	while (IS_CONTROL_LOCK_ENABLED)
	{
		if (vexRT[BTN_CONTROL_LOCK_1] == 1 && vexRT[BTN_CONTROL_LOCK_2] == 1 && lockControls)
		{
			while (vexRT[BTN_CONTROL_LOCK_1] == 1 && vexRT[BTN_CONTROL_LOCK_2] == 1) wait1Msec(10);
			lockControls = false;
		}
		else if (vexRT[BTN_CONTROL_LOCK_1] == 1 && vexRT[BTN_CONTROL_LOCK_2] == 1 && !lockControls)
		{
			while (vexRT[BTN_CONTROL_LOCK_1] == 1 && vexRT[BTN_CONTROL_LOCK_2] == 1) wait1Msec(10);
			lockControls = true;
		}
	}
}


#define FLAG_BIT_DRIVE_ACTIVE					1
#define FLAG_BIT_GYRO_ACTIVE					2
#define FLAG_BIT_ARM_ACTIVE						4
#define FLAG_BIT_MINI_4_BAR_EXTENDED			8
#define FLAG_BIT_MINI_4_BAR_RETRACTED			16
#define FLAG_BIT_MOGO_LIFT_EXTENDED				32
#define FLAG_BIT_MOGO_LIFT_RETRACTED			64
#define FLAG_BIT_MOGO_LIFT_HALFWAY				128
#define FLAG_BIT_GOLIATH_INTAKE					256
#define FLAG_BIT_GOLIATH_OUTTAKE				512
#define FLAG_BIT_ARM_READY_MACRO_ACTIVE			1024
#define FLAG_BIT_MOGO_STACK_CONE_MACRO_ACTIVE	2048

short lastFlag;
short currentFlag;

short getCurrentFlag()
{
	short flag = 0;

	if (getDriveLeftMotorPower() > 0 && getDriveRightMotorPower() < 0) flag += FLAG_BIT_GYRO_ACTIVE;
	else if (getDriveLeftMotorPower() < 0 && getDriveRightMotorPower() > 0) flag += FLAG_BIT_GYRO_ACTIVE;
	else if (abs(getDriveLeftMotorPower()) > 0) flag += FLAG_BIT_DRIVE_ACTIVE;

	if (abs(getArmMotorPower()) > 0) flag += FLAG_BIT_ARM_ACTIVE;

	if (getGoliathMotorPower() > 0) flag += FLAG_BIT_GOLIATH_INTAKE;
	else if (getGoliathMotorPower() < 0) flag += FLAG_BIT_GOLIATH_OUTTAKE;

	if (stateMini4BarCurrent == STATE_EXTENSION_EXTENDED) flag += FLAG_BIT_MINI_4_BAR_EXTENDED;
	else if (stateMini4BarCurrent == STATE_EXTENSION_RETRACTED) flag += FLAG_BIT_MINI_4_BAR_RETRACTED;

	if (stateMoGoLiftCurrent == STATE_EXTENSION_EXTENDED) flag += FLAG_BIT_MOGO_LIFT_EXTENDED;
	else if (stateMoGoLiftCurrent == STATE_EXTENSION_RETRACTED) flag += FLAG_BIT_MOGO_LIFT_RETRACTED;
	else if (stateMoGoLiftCurrent == STATE_EXTENSION_HALFWAY) flag += FLAG_BIT_MOGO_LIFT_HALFWAY;

	if (isArmReadyMacroActive) flag += FLAG_BIT_ARM_READY_MACRO_ACTIVE;
	else if (isMoGoStackConeMacroActive) flag += FLAG_BIT_MOGO_STACK_CONE_MACRO_ACTIVE;

	return flag;
}

bool isFlagBitChangedToTrue(short flagBit)
{
	return ( !(lastFlag & flagBit) && (currentFlag & flagBit) );
}

bool isFlagBitChangedToFalse(short flagBit)
{
	return ( (lastFlag & flagBit) && !(currentFlag & flagBit) );
}



task AutonRecorder()
{
	Action actions[70];

	startTask(usercontrol);
	isAutonRecorderEnabled = true;

	numOfInternalCones = 0;

	lastFlag = getCurrentFlag();
	currentFlag = getCurrentFlag();

	SensorValue[encoderDriveLeft] = 0;
	SensorValue[encoderDriveRight] = 0;
	SensorValue[gyro1] = 0;
	SensorValue[gyro2] = 0;


	short goalPoints[70];

	for (ubyte i = 0; i < 70; i++)
	{
		actions[i] = A_NONE;
	}

	ubyte idx = 0;

	ubyte lastDriveIdx = 0;
	ubyte lastArmIdx = 0;
	ubyte lastGyroIdx = 0;

	bool isDriveDone = false;
	bool isArmDone = false;
	bool isGyroDone = false;


	while (vexRT[BTN_STOP_AUTON_RECORDER] == 0)
	{
		while (lastFlag == currentFlag && vexRT[BTN_STOP_AUTON_RECORDER] == 0) { currentFlag = getCurrentFlag(); }


		if (isFlagBitChangedToTrue(FLAG_BIT_DRIVE_ACTIVE) && idx != 0 && actions[idx - 1] == A_DRIVE ) isDriveDone = false;
		else if (isFlagBitChangedToFalse(FLAG_BIT_DRIVE_ACTIVE)) isDriveDone = true;
		else if (!isFlagBitChangedToTrue(FLAG_BIT_DRIVE_ACTIVE) && !isFlagBitChangedToFalse(FLAG_BIT_DRIVE_ACTIVE) && isDriveDone)
		{
			goalPoints[lastDriveIdx] = SensorValue[encoderDriveLeft];
			if (actions[idx - 1] != A_DRIVE) {
				Action tempAction = actions[idx - 1];
				actions[idx - 1] = A_DRIVE_WAIT;
				actions[idx++] = tempAction;
			}
			else actions[idx++] = A_DRIVE_WAIT;
			SensorValue[encoderDriveLeft] = 0;
			SensorValue[encoderDriveRight] = 0;
			isDriveDone = false;
		}


		if (isFlagBitChangedToTrue(FLAG_BIT_GYRO_ACTIVE) && idx != 0 && actions[idx - 1] == A_GYRO ) isGyroDone = false;
		else if (isFlagBitChangedToFalse(FLAG_BIT_GYRO_ACTIVE)) isGyroDone = true;
		else if (!isFlagBitChangedToTrue(FLAG_BIT_GYRO_ACTIVE) && !isFlagBitChangedToFalse(FLAG_BIT_GYRO_ACTIVE) && isGyroDone)
		{
			goalPoints[lastGyroIdx] = getGyroSensorValue();
			if (actions[idx - 1] != A_GYRO)
			{
				Action tempAction = actions[idx - 1];
				actions[idx - 1] = A_GYRO_WAIT;
				actions[idx++] = tempAction;
			}
			else actions[idx++] = A_GYRO_WAIT;
			isGyroDone = false;
		}


		if (isFlagBitChangedToTrue(FLAG_BIT_ARM_ACTIVE) && idx != 0 && actions[idx - 1] == A_ARM) isArmDone = false;
		else if (isFlagBitChangedToFalse(FLAG_BIT_ARM_ACTIVE)) isArmDone = true;
		else if (!isFlagBitChangedToTrue(FLAG_BIT_ARM_ACTIVE) && !isFlagBitChangedToFalse(FLAG_BIT_ARM_ACTIVE) && isArmDone)
		{
			goalPoints[lastArmIdx] = SensorValue[potentiometerArm];
			if (actions[idx - 1] != A_ARM)
			{
				Action tempAction = actions[idx - 1];
				actions[idx - 1] = A_ARM_WAIT;
				actions[idx++] = tempAction;
			}
			else actions[idx++] = A_ARM_WAIT;
			isArmDone = false;
		}


		if (isFlagBitChangedToTrue(FLAG_BIT_GOLIATH_INTAKE))
		{
			actions[idx] = A_GOLIATH;
			goalPoints[idx++] = STATE_GOLIATH_INTAKE;
		}
		else if (isFlagBitChangedToTrue(FLAG_BIT_GOLIATH_OUTTAKE))
		{
			actions[idx] = A_GOLIATH;
			goalPoints[idx++] = STATE_GOLIATH_OUTTAKE;
		}


		if (isFlagBitChangedToTrue(FLAG_BIT_MINI_4_BAR_EXTENDED))
		{
			actions[idx] = A_MINI_4_BAR;
			goalPoints[idx++] = STATE_EXTENSION_EXTENDED;
		}
		else if (isFlagBitChangedToTrue(FLAG_BIT_MINI_4_BAR_RETRACTED))
		{
			actions[idx] = A_MINI_4_BAR;
			goalPoints[idx++] = STATE_EXTENSION_RETRACTED;
		}


		if (isFlagBitChangedToTrue(FLAG_BIT_MOGO_LIFT_EXTENDED))
		{
			actions[idx] = A_MOGO_LIFT;
			goalPoints[idx++] = STATE_EXTENSION_EXTENDED;
		}
		else if (isFlagBitChangedToTrue(FLAG_BIT_MOGO_LIFT_RETRACTED))
		{
			actions[idx] = A_MOGO_LIFT;
			goalPoints[idx++] = STATE_EXTENSION_RETRACTED;
		}
		else if (isFlagBitChangedToTrue(FLAG_BIT_MOGO_LIFT_HALFWAY))
		{
			actions[idx] = A_MOGO_LIFT;
			goalPoints[idx++] = STATE_EXTENSION_HALFWAY;
		}


		if (isFlagBitChangedToTrue(FLAG_BIT_ARM_READY_MACRO_ACTIVE))
		{
			actions[idx++] = A_ARM_READY_MACRO;
			isArmReadyMacroActive = true;
			while (isArmReadyMacroActive) { }
		}
		else if (isFlagBitChangedToTrue(FLAG_BIT_MOGO_STACK_CONE_MACRO_ACTIVE))
		{
			actions[idx++] = A_MOGO_CARRY_CONE_MACRO;
			isMoGoStackConeMacroActive = true;
			while (isMoGoStackConeMacroActive) { }
		}


		if ((isFlagBitChangedToTrue(FLAG_BIT_DRIVE_ACTIVE) && idx != 0 && actions[idx - 1] != A_DRIVE) || (isFlagBitChangedToTrue(FLAG_BIT_DRIVE_ACTIVE) && idx == 0))
		{
			actions[idx] = A_DRIVE;
			SensorValue[encoderDriveLeft] = 0;
			SensorValue[encoderDriveRight] = 0;
			lastDriveIdx = idx++;
		}
		else if ( (isFlagBitChangedToTrue(FLAG_BIT_GYRO_ACTIVE) && idx != 0 && actions[idx - 1] != A_GYRO) || (isFlagBitChangedToTrue(FLAG_BIT_GYRO_ACTIVE) && idx == 0) )
		{
			actions[idx] = A_GYRO;
			lastGyroIdx = idx++;
		}


		if ( (isFlagBitChangedToTrue(FLAG_BIT_ARM_ACTIVE) && idx != 0 && actions[idx - 1] != A_ARM) || (isFlagBitChangedToTrue(FLAG_BIT_ARM_ACTIVE) && idx == 0) )
		{
			actions[idx] = A_ARM;
			lastArmIdx = idx++;
		}


		lastFlag = currentFlag;

	}

	string debugLine1;
	string debugLine2;
	string debugLine3;
	string debugLine4;
	clearDebugStream();

	for (ubyte i = 0; i < 40 && actions[i+1] != A_NONE; i++)
	{
		if (actions[i] == A_DRIVE)
		{
			debugLine1 = "startTDrivePID(";
			debugLine2 = ConvertIntegerToString(goalPoints[i]);
			debugLine2 += ");";
			debugLine3 = "";
			debugLine4 = "";
		}
		else if (actions[i] == A_ARM)
		{
			debugLine1 = "startTArmPID(";
			debugLine2 = ConvertIntegerToString(goalPoints[i]);
			debugLine2 += ", WAIT);";
			debugLine3 = "";
			debugLine4 = "";
		}
		else if (actions[i] == A_GYRO)
		{
			debugLine1 = "startTGyroPID(";
			debugLine2 = ConvertIntegerToString(goalPoints[i] / 10);
			debugLine2 += ");";
			debugLine3 = "";
			debugLine4 = "";
		}
		else if (actions[i] == A_GOLIATH)
		{
			if (goalPoints[i] == (short) STATE_GOLIATH_INTAKE) { debugLine1 = "setGoliathMotor"; debugLine2 = "Power(50);"; debugLine3 = ""; debugLine4 = ""; }
			else if (goalPoints[i] == (short) STATE_GOLIATH_OUTTAKE) { debugLine1 = "setGoliathMotor"; debugLine2 = "Power(-50);"; debugLine3 = ""; debugLine4 = ""; }
		}
		else if (actions[i] == A_MOGO_LIFT)
		{
			if (goalPoints[i] == (short) STATE_EXTENSION_EXTENDED) { debugLine1 = "startTMoGoLift(ST"; debugLine2 = "ATE_EXTENSION_EXTEN"; debugLine3 = "DED);"; debugLine4 = ""; }
			else if (goalPoints[i] == (short) STATE_EXTENSION_RETRACTED) { debugLine1 = "startTMoGoLift(ST"; debugLine2 = "ATE_EXTENSION_RETR"; debugLine3 = "ACTED);"; debugLine4 = ""; }
			else if (goalPoints[i] == (short) STATE_EXTENSION_HALFWAY) { debugLine1 = "startTMoGoLift(ST"; debugLine2 = "ATE_EXTENSION_HALF"; debugLine3 = "WAY);"; debugLine4 = ""; }
		}
		else if (actions[i] == A_MINI_4_BAR)
		{
			if (goalPoints[i] == (short) STATE_EXTENSION_EXTENDED) { debugLine1 = "mini4BarExtend(WA"; debugLine2 = "IT);"; debugLine3 = ""; debugLine4 = "waitForTMini4Bar();"; }
			else if (goalPoints[i] == (short) STATE_EXTENSION_RETRACTED) { debugLine1 = "mini4BarRetract("; debugLine2 = "WAIT);"; debugLine3 = ""; debugLine4 = "waitForTMini4Bar();"; }
		}
		else if (actions[i] == A_ARM_READY_MACRO)
		{
			debugLine1 = "startTMacro(MACR"; debugLine1 = "O_ARM_READY);"; debugLine3 = ""; debugLine4 = "";
		}
		else if (actions[i] == A_MOGO_CARRY_CONE_MACRO)
		{
			debugLine1 = "startTMacro(MACRO"; debugLine2 = "_MOGO_STACK_CONE);"; debugLine3 = ""; debugLine4 = "";
		}
		else if (actions[i] == A_DRIVE_WAIT)
		{
			debugLine1 = "waitForTDrive();"; debugLine2 = ""; debugLine3 = ""; debugLine4 = "";
		}
		else if (actions[i] == A_ARM_WAIT)
		{
			debugLine1 = "waitForTArm();"; debugLine2 = ""; debugLine3 = ""; debugLine4 = "";
		}
		else if (actions[i] == A_GYRO_WAIT)
		{
			debugLine1 = "waitForTGyroPID();"; debugLine2 = ""; debugLine3 = ""; debugLine4 = "";
		}

		writeDebugStream(debugLine1);
		writeDebugStream(debugLine2);
		writeDebugStream(debugLine3);
		writeDebugStream(debugLine4);
		writeDebugStream("\n\r");
	}

	isAutonRecorderEnabled = false;
}





/* Start up program based on currently selected program and direction */
void startUp()
{
	stopTasks();
	allMotorsOff();

	string programName = (*selectedProgram).name;
	if ((*selectedProgram).isDirectional)
	{
		if (autonomousSide == SIDE_LEFT) programName += "L";
		else if (autonomousSide == SIDE_RIGHT) programName += "R";

		if (autonomousColor == COLOR_BLUE) programName += "B";
		else if (autonomousColor == COLOR_RED) programName += "R";
	}

	if ((*selectedProgram).id == menuItemUserControl.id) startTask(usercontrol);
	else if ( (*selectedProgram).id == menuItemAutonRecorder.id) startTask(AutonRecorder);
	else if ( (*selectedProgram).id == menuItemMotorCheckAuto.id || (*selectedProgram).id == menuItemMotorCheckManual.id) startTask(MiscellaneousTask);
	else if ((*selectedProgram).idx < MENU_LIST_PID_LENGTH && (*menuListPID[ (*selectedProgram).idx ]).id == (*selectedProgram).id)
	{
		/* Countdown if autonomous is selected */
		programName += " PID";
		displayLCDCenteredString(0, programName);
		clearLCDLine(1);
		displayLCDString(1, 2, "Starts In 3");
		wait1Msec(1000);
		displayLCDString(1, 12, "2");
		wait1Msec(1000);
		displayLCDString(1, 12, "1");
		wait1Msec(1000);

		startTask(MiscellaneousTask);
	}
	else if ((*selectedProgram).idx < MENU_LIST_AUTON_LENGTH && (*menuListAuton[ (*selectedProgram).idx ]).id == (*selectedProgram).id )
	{
		/* Countdown if autonomous is selected */
		displayLCDCenteredString(0, programName);
		clearLCDLine(1);
		displayLCDString(1, 2, "Starts In 3");
		wait1Msec(1000);
		displayLCDString(1, 12, "2");
		wait1Msec(1000);
		displayLCDString(1, 12, "1");
		wait1Msec(1000);

		startTask(autonomous);
	}
}












task playMissionImpossibleMusic()
{
	//        100 = Tempo
	//          6 = Default octave
	//    Quarter = Default note length
	//        10% = Break between notes
	//
	playTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
	playTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
	playTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
	playTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
	playTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
	playTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
	playTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
	playTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
	playTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
	playTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
	playTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
	playTone(  988,    7); wait1Msec(  75);  // Note(E, Duration(32th))
	playTone( 1047,    7); wait1Msec(  75);  // Note(F, Duration(32th))
	playTone( 1109,    7); wait1Msec(  75);  // Note(F#, Duration(32th))
	playTone( 1175,    7); wait1Msec(  75);  // Note(G, Duration(32th))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	playTone( 1398,   14); wait1Msec( 150);  // Note(A#, Duration(16th))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone(  784,   14); wait1Msec( 150);  // Note(C, Duration(16th))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	playTone( 1047,   14); wait1Msec( 150);  // Note(F, Duration(16th))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone( 1109,   14); wait1Msec( 150);  // Note(F#, Duration(16th))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	playTone( 1398,   14); wait1Msec( 150);  // Note(A#, Duration(16th))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone(  784,   14); wait1Msec( 150);  // Note(C, Duration(16th))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	playTone( 1047,   14); wait1Msec( 150);  // Note(F, Duration(16th))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone( 1109,   14); wait1Msec( 150);  // Note(F#, Duration(16th))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone( 1398,   14); wait1Msec( 150);  // Note(A#, Duration(16th))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(  880,  108); wait1Msec(1200);  // Note(D, Duration(Half))
	playTone(    0,    7); wait1Msec(  75);  // Note(Rest, Duration(32th))
	playTone( 1398,   14); wait1Msec( 150);  // Note(A#, Duration(16th))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(  831,  108); wait1Msec(1200);  // Note(C#, Duration(Half))
	playTone(    0,    7); wait1Msec(  75);  // Note(Rest, Duration(32th))
	playTone( 1398,   14); wait1Msec( 150);  // Note(A#, Duration(16th))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(  784,  108); wait1Msec(1200);  // Note(C, Duration(Half))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone(  932,   14); wait1Msec( 150);  // Note(A#5, Duration(16th))
	playTone(  784,   14); wait1Msec( 150);  // Note(C, Duration(16th))

}









/* Stop all non-vital tasks */
void stopTasks()
{
	stopTask(autonomous);
	stopTask(Arm);
	stopTask(Drive);
	stopTask(Goliath);
	stopTask(Mini4Bar);
	stopTask(MoGoLift);
	stopTask(usercontrol);
	stopTask(tDrivePIDControl);
	stopTask(tArmPIDControl);
	stopTask(tMoGoLift);
	stopTask(tMini4Bar);
	stopTask(tGyroFace);
	stopTask(tGyroPIDControl);
	stopTask(AutonRecorder);
	stopTask(playMissionImpossibleMusic);
	stopTask(tMacro);
	stopTask(MiscellaneousTask);
}
